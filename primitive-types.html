<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Tipi primitivi</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduzione</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Come Iniziare</a>
</li>
<li><a  href='guessing-game.html'><b>3.</b> Tutorial: Gioco-indovina</a>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> Sintassi e semantica</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>4.1.</b> Legami di variabili</a>
</li>
<li><a  href='functions.html'><b>4.2.</b> Funzioni</a>
</li>
<li><a class='active' href='primitive-types.html'><b>4.3.</b> Tipi primitivi</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> Commenti</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>4.6.</b> Cicli</a>
</li>
<li><a  href='vectors.html'><b>4.7.</b> Vettori</a>
</li>
<li><a  href='ownership.html'><b>4.8.</b> Possesso</a>
</li>
<li><a  href='references-and-borrowing.html'><b>4.9.</b> Riferimenti e prestito</a>
</li>
<li><a  href='lifetimes.html'><b>4.10.</b> Tempo di vita</a>
</li>
<li><a  href='mutability.html'><b>4.11.</b> MutabilitÃ </a>
</li>
<li><a  href='structs.html'><b>4.12.</b> Strutture</a>
</li>
<li><a  href='enums.html'><b>4.13.</b> Enumerazioni</a>
</li>
<li><a  href='match.html'><b>4.14.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>4.15.</b> Pattern</a>
</li>
<li><a  href='method-syntax.html'><b>4.16.</b> Sintassi dei metodi</a>
</li>
<li><a  href='strings.html'><b>4.17.</b> Stringhe</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> GenericitÃ </a>
</li>
<li><a  href='traits.html'><b>4.19.</b> Tratti</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> `if let`</a>
</li>
<li><a  href='trait-objects.html'><b>4.22.</b> Oggetti-tratti</a>
</li>
<li><a  href='closures.html'><b>4.23.</b> Chiusure</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> Sintassi universale di chiamata di funzione</a>
</li>
<li><a  href='crates-and-modules.html'><b>4.25.</b> Crate e moduli</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const` e `static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> Attributi</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> Alias tramite `type`</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> Forzatura di tipo</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> Tipi associati</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> Tipi non dimensionati</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> Operatori e sovraccaricamento</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Coercizione Deref</a>
</li>
<li><a  href='macros.html'><b>4.34.</b> Le macro</a>
</li>
<li><a  href='raw-pointers.html'><b>4.35.</b> Puntatori grezzi</a>
</li>
<li><a  href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Rust efficace</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> Lo stack e lo heap</a>
</li>
<li><a  href='testing.html'><b>5.2.</b> Collaudo</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> Compilazione condizionale</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> Documentazione</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> Iteratori</a>
</li>
<li><a  href='concurrency.html'><b>5.6.</b> Concorrenza</a>
</li>
<li><a  href='error-handling.html'><b>5.7.</b> Gestione degli errori</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> Scegliere le garanzie</a>
</li>
<li><a  href='ffi.html'><b>5.9.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> Prestito e AsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> Canali di rilascio</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> Usare Rust senza la libreria standard</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Rust notturno</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Plugin del compilatore</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Assembly in-line</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> Omettere la libreria stdandard</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinseci</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Elementi "lang"</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> Link avanzato</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Collaudi prestazionali</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Sintassi di box e relativi pattern</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Pattern di slice</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Costanti associate</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> Allocatori personalizzati</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> Glossario</a>
</li>
<li><a  href='syntax-index.html'><b>8.</b> Indice analitico della sintassi</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Tipi primitivi</h1>
    <p>Il linguaggio Rust ha vari tipi che sono considerati â€˜primitiviâ€™. CiÃ²
significa che fanno parte del linguaggio. Rust Ã¨ strutturato in modo tale
che la libreria standard fornisca anche vari altri tipi utili, costruiti
basandosi su quelli primitivi, ma quelli che vedremo sono i piÃ¹ primitivi.</p>

<h1 id='booleani' class='section-header'><a href='#booleani'>Booleani</a></h1>
<p>Rust ha un tipo booleano primitivo, chiamato <code>bool</code>. Ha solo due valori,
<code>true</code> (&quot;vero&quot;) e <code>false</code> (&quot;falso&quot;):</p>

<span class='rusttest'>fn main() {
    let x = true;

let y: bool = false;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='bool-val'>true</span>;

<span class='kw'>let</span> <span class='ident'>y</span>: <span class='ident'>bool</span> <span class='op'>=</span> <span class='bool-val'>false</span>;</pre>

<p>I booleani sono usati tipicamente nei costrutti <a href="if.html"><code>if</code></a>.</p>

<p>Nella <a href="../std/primitive.bool.html">documentazione della libreria standard</a> si trova ulteriore
documentazione sui <code>bool</code>.</p>

<h1 id='char' class='section-header'><a href='#char'><code>char</code></a></h1>
<p>Il tipo <code>char</code> rappresenta un singolo valore scalare Unicode. Si possono
creare dei <code>char</code> racchiudendoli tra apici singoli: (<code>&#39;</code>)</p>

<span class='rusttest'>fn main() {
    let x = &#39;x&#39;;
let two_hearts = &#39;ðŸ’•&#39;;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='string'>&#39;x&#39;</span>;
<span class='kw'>let</span> <span class='ident'>two_hearts</span> <span class='op'>=</span> <span class='string'>&#39;ðŸ’•&#39;</span>;</pre>

<p>Diversamente da alcuni altri linguaggi, ciÃ² significa che il <code>char</code> di Rust
non Ã¨ rappresentato con un singolo byte, ma da quattro byte.</p>

<p>Nella <a href="../std/primitive.char.html">documentazione della libreria standard</a> si trova ulteriore
documentazione sui <code>char</code>.</p>

<h1 id='tipi-numerici' class='section-header'><a href='#tipi-numerici'>Tipi numerici</a></h1>
<p>Rust ha parecchi tipi numerici, appartenenti alle seguenti categorie:
con segno e senza segno, fissi e variabili, a virgola mobile e interi.</p>

<p>Questi tipi consistono di due parti: la categoria, e la dimensione.
Per esempio, <code>u16</code> Ã¨ un tipo senza segno con una dimensione di sedici bit.
PiÃ¹ bit consentono di rappresentare numeri piÃ¹ grandi.</p>

<p>Se un letterale numerico non specifica il tipo esatto a cui appartiene,
il suo tipo viene inferito nel seguente modo:</p>

<span class='rusttest'>fn main() {
    let x = 42; // x ha tipo i32

let y = 1.0; // y ha tipo f64
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>42</span>; <span class='comment'>// x ha tipo i32</span>

<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>1.0</span>; <span class='comment'>// y ha tipo f64</span></pre>

<p>Ecco una lista dei diversi tipi numerici, con dei link alla loro documentazione
nella libreria standard:</p>

<ul>
<li><a href="../std/primitive.i8.html">i8</a></li>
<li><a href="../std/primitive.i16.html">i16</a></li>
<li><a href="../std/primitive.i32.html">i32</a></li>
<li><a href="../std/primitive.i64.html">i64</a></li>
<li><a href="../std/primitive.u8.html">u8</a></li>
<li><a href="../std/primitive.u16.html">u16</a></li>
<li><a href="../std/primitive.u32.html">u32</a></li>
<li><a href="../std/primitive.u64.html">u64</a></li>
<li><a href="../std/primitive.isize.html">isize</a></li>
<li><a href="../std/primitive.usize.html">usize</a></li>
<li><a href="../std/primitive.f32.html">f32</a></li>
<li><a href="../std/primitive.f64.html">f64</a></li>
</ul>

<p>Esaminiamoli in base alla loro categoria:</p>

<h2 id='con-segno-e-senza-segno' class='section-header'><a href='#con-segno-e-senza-segno'>Con segno e senza segno</a></h2>
<p>Ci sono due categorie di tipi interi: con segno e senza segno. Per comprendere
la differenza, consideriamo un numero di quattro bit. Un numero di quattro bit,
con segno, consentirebbe di rappresentare i numeri da <code>-8</code> a <code>+7</code>. I numeri
con segno usano la &quot;rappresentazione in complemento a due&quot;. Un numero
di quattro bit, senza segno, dato che non ha bisogno di rappresentare
valori negativi, puÃ² rappresentare valori da <code>0</code> a <code>+15</code>.</p>

<p>I tipi con segno usano una <code>u</code> per la loro categoria, e i tipi con segno
usano una <code>i</code>. La <code>u</code> sta per â€˜unsignedâ€™ (&quot;senza segno&quot;), mentre la <code>i</code>
sta per â€˜integerâ€™ (&quot;intero&quot;). PerciÃ² <code>u8</code> Ã¨ un numero senza segno, a otto bit,
 e <code>i8</code> Ã¨ un numero con segno, sempre a otto bit.</p>

<h2 id='tipi-a-dimensione-fissa' class='section-header'><a href='#tipi-a-dimensione-fissa'>Tipi a dimensione fissa</a></h2>
<p>I tipi dimensione fissa hanno uno specifico numero di bit nella loro
rappresentazione. Le dimensioni in bit valide sono <code>8</code>, <code>16</code>, <code>32</code>, e <code>64</code>.
PerciÃ², <code>u32</code> Ã¨ un intero senza segno, a 32 bit,
e <code>i64</code> Ã¨ un intero con segno, a 64 bit.</p>

<h2 id='tipi-a-dimensione-variabile' class='section-header'><a href='#tipi-a-dimensione-variabile'>Tipi a dimensione variabile</a></h2>
<p>Rust fornisce anche dei tipi la cui effettiva dimensione dipende
dall&#39;architettura della macchina in questione.
L&#39;ampiezza di questi tipi Ã¨ sufficiente
ad esprimere la dimensione di qualunque collezione, perciÃ² questi tipi
appartengono alla categoria â€˜sizeâ€™ (&#39;dimensione&#39;). Anche loro hanno
la versione con segno e quella senza segno, e quindi sono due:
<code>isize</code> e <code>usize</code>.</p>

<h2 id='tipi-a-virgola-mobile' class='section-header'><a href='#tipi-a-virgola-mobile'>Tipi a virgola mobile</a></h2>
<p>Rust ha anche due tipi a virgola mobile: <code>f32</code> e <code>f64</code>. Questi corrispondono
rispettivamente ai numeri a precisione singola e a precisione doppia
secondo lo standard IEEE-754.</p>

<h1 id='arrays' class='section-header'><a href='#arrays'>Arrays</a></h1>
<p>Come molti linguaggi di programmazione, Rust ha dei tipi compositi
per rappresentare sequenze di dati. Il piÃ¹ basilare Ã¨ il tipo <em>array</em>
(&quot;schiera&quot;), una lista a lunghezza fissa di elementi dello stesso tipo.
Di default, gli array sono immutabili.</p>

<span class='rusttest'>fn main() {
    let a = [1, 2, 3]; // a: [i32; 3]
let mut m = [1, 2, 3]; // m: [i32; 3]
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>]; <span class='comment'>// a: [i32; 3]</span>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>m</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>]; <span class='comment'>// m: [i32; 3]</span></pre>

<p>Gli arrays hanno tipo <code>[T; N]</code>. Parleremo di questa notazione <code>T</code> nella
[sezione sulla genericitÃ ][generics]. La <code>N</code> Ã¨ una costante nota in fase
di compilazione, che indica il numero di oggetti contenuto nell&#39;array.</p>

<p>C&#39;Ã¨ un&#39;abbreviazione per inizializzare ogni elemento di un array allo stesso
valore. Ecco come inizializzare a <code>0</code> ognuno dei 20 elementi dell&#39;array <code>a</code>:</p>

<span class='rusttest'>fn main() {
    let a = [0; 20]; // a: [i32; 20]
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>0</span>; <span class='number'>20</span>]; <span class='comment'>// a: [i32; 20]</span></pre>

<p>Si puÃ² ottenere il numero di elementi di un array <code>a</code> con l&#39;espressione
<code>a.len()</code>:</p>

<span class='rusttest'>fn main() {
    let a = [1, 2, 3];

println!(&quot;a ha {} elementi&quot;, a.len());
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;a ha {} elementi&quot;</span>, <span class='ident'>a</span>.<span class='ident'>len</span>());</pre>

<p>Si puÃ² accedere a un particolare elemento di un array con
la <em>notazione a indice</em>:</p>

<span class='rusttest'>fn main() {
    let nomi = [&quot;Graydon&quot;, &quot;Brian&quot;, &quot;Niko&quot;]; // nomi: [&amp;str; 3]

println!(&quot;Il secondo nome Ã¨: {}&quot;, nomi[1]);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>nomi</span> <span class='op'>=</span> [<span class='string'>&quot;Graydon&quot;</span>, <span class='string'>&quot;Brian&quot;</span>, <span class='string'>&quot;Niko&quot;</span>]; <span class='comment'>// nomi: [&amp;str; 3]</span>

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Il secondo nome Ã¨: {}&quot;</span>, <span class='ident'>nomi</span>[<span class='number'>1</span>]);</pre>

<p>Gli indici partono da zero, come nella maggior parte dei linguaggi
di programmazione, e perciÃ² il primo nome Ã¨ <code>nomi[0]</code> e il secondo nome Ã¨
<code>nomi[1]</code>. L&#39;esempio precedente stampa <code>Il secondo nome Ã¨: Brian</code>.
Provando ad usare un indice non compreso nell&#39;array, si ottiene un errore,
perchÃ© per ogni accesso ad un array, in fase di esecuzione si verifica
che l&#39;indice sia compreso nei limiti. Accessi erronei di questo tipo
causano molti bug in altri linguaggi di programmazione di sistema.</p>

<p>Per maggiori informazioni sugli array si consulti <a href="../std/primitive.array.html">la documentazione sulla
libreria standard</a>.</p>

<h1 id='slices-fette' class='section-header'><a href='#slices-fette'>Slices (&quot;Fette&quot;)</a></h1>
<p>Le â€˜slicesâ€™ (pronunciato &quot;slaises&quot;) sono riferimenti a (o â€œviste&quot; dentro)
un&#39;altra struttura dati.
Servono a consentire un accesso sicuro ed efficiente ad una porzione
di un array senza fare copie. Per esempio, si potrebbe voler far riferimento
solamente ad una riga di un file letto in memoria. Per sua natura, una slice
non viene creata direttamente, ma partendo da un legame di variabile esistente.
Le slices hanno una lunghezza fissa, e il loro contenuto
puÃ² essere mutabile o immutabile.</p>

<p>Internamente, le slice sono rappresentate come un puntatore all&#39;inizio
dei dati e una lunghezza.</p>

<h2 id='sintassi-delle-slices' class='section-header'><a href='#sintassi-delle-slices'>Sintassi delle slices</a></h2>
<p>Per creare una slice da vari oggetti si puÃ² usare la combinazione
del carattere <code>&amp;</code> e della coppia di caratteri <code>[]</code>. Il carattere <code>&amp;</code> indica
che le slices sono simili ai [riferimenti], che tratteremo in dettaglio
piÃ¹ avanti in questa sezione. La coppia di caratteri <code>[]</code>, utilizzata con un
range, permette di definire la lunghezza della slice:</p>

<span class='rusttest'>fn main() {
    let a = [0, 1, 2, 3, 4];
let completo = &amp;a[..]; // Una slice contenente tutti gli elementi di a
let mezzo = &amp;a[1..4]; // Una slice contenente solo gli elementi 1, 2, e 3
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>0</span>, <span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>];
<span class='kw'>let</span> <span class='ident'>completo</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>a</span>[..]; <span class='comment'>// Una slice contenente tutti gli elementi di a</span>
<span class='kw'>let</span> <span class='ident'>mezzo</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>a</span>[<span class='number'>1</span>..<span class='number'>4</span>]; <span class='comment'>// Una slice contenente solo gli elementi 1, 2, e 3</span></pre>

<p>Le slice sono di tipo <code>&amp;[T]</code>. Parleremo di quella <code>T</code> quando tratteremo la
<a href="generics.html">genericitÃ </a>.</p>

<p>Per maggiori informazioni sulle slices si consulti <a href="../std/primitive.slice.html">la documentazione sulla
libreria standard</a>.</p>

<h1 id='str' class='section-header'><a href='#str'><code>str</code></a></h1>
<p>Il tipo <code>str</code> di Rust Ã¨ il tipo di stringa piÃ¹ primitivo.
Come <a href="unsized-types.html">tipo unsized</a>, non Ã¨ molto utile di suo, ma diventa utile quando Ã¨
utilizzato come riferimento, come per esempio <code>&amp;str</code>. Tratteremo l&#39;argomento
in maniera piÃ¹ approfondita quando tratteremo le
<a href="strings.html">Stringhe</a> e i <a href="references-and-borrowing.html">riferimenti</a>.</p>

<p>Per maggiori informazioni sul tipo <code>str</code> si consulti <a href="../std/primitive.str.html">la documentazione sulla
libreria standard</a>.</p>

<h1 id='ennuple' class='section-header'><a href='#ennuple'>Ennuple</a></h1>
<p>Una ennupla Ã¨ una lista ordinata di lunghezza fissa. Come questa:</p>

<span class='rusttest'>fn main() {
    let x = (1, &quot;ciao&quot;);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> (<span class='number'>1</span>, <span class='string'>&quot;ciao&quot;</span>);</pre>

<p>Le parentesi e le virgole formano questa ennupla di lunghezza due. Ecco
lo stesso codice, ma con il tipo annotato:</p>

<span class='rusttest'>fn main() {
    let x: (i32, &amp;str) = (1, &quot;ciao&quot;);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: (<span class='ident'>i32</span>, <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>=</span> (<span class='number'>1</span>, <span class='string'>&quot;ciao&quot;</span>);</pre>

<p>Come si vede, il tipo di una ennupla somiglia all&#39;ennupla, ma in ogni posizione
c&#39;Ã¨ il tipo invece del valore. I lettori attenti noteranno anche che
le ennuple sono eterogenee: in questa ennupla c&#39;Ã¨ un <code>i32</code> e un <code>&amp;str</code>.
Nei linguaggi di programmazione di sistema, le stringhe sono un pochino piÃ¹
complesse che negli altri linguaggi. Per adesso, si legga <code>&amp;str</code> come <em>slice
di stringa</em>, presto impareremo di piÃ¹ a riguardo.</p>

<p>Ãˆ possibile assegnare un bind su una ennupla ad un&#39;altra ennupla,
se entrambe le ennuple contengono gli
stessi tipi di dato e hanno la stessa <a href="glossary.html#arity">arity</a>. Le tuple hanno la stessa arity
quando hanno la stessa lunghezza.</p>

<span class='rusttest'>fn main() {
    let mut x = (1, 2); // x: (i32, i32)
let y = (2, 3); // y: (i32, i32)

x = y;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> (<span class='number'>1</span>, <span class='number'>2</span>); <span class='comment'>// x: (i32, i32)</span>
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> (<span class='number'>2</span>, <span class='number'>3</span>); <span class='comment'>// y: (i32, i32)</span>

<span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>y</span>;</pre>

<p>Si puÃ² accedere ai campi di una ennupla usando un <em><code>let</code> destrutturante</em>.
Ecco un esempio:</p>

<span class='rusttest'>fn main() {
    let (x, y, z) = (1, 2, 3);

println!(&quot;x is {}&quot;, x);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> (<span class='ident'>x</span>, <span class='ident'>y</span>, <span class='ident'>z</span>) <span class='op'>=</span> (<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>);

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x is {}&quot;</span>, <span class='ident'>x</span>);</pre>

<p>Ci ricordiamo di quando <a href="variable-bindings.html">prima</a> abbiamo detto che la parte sinistra di una
istruzione <code>let</code> non era solo capace di fare un legame di variabile? Qui lo
vediamo. Possiamo scrivere un pattern nella parte sinistra di una istruzione
<code>let</code>, e se questo corrisponde alla parte destra, possiamo assegnare piÃ¹
legami di variabile alla volta. In questo caso, <code>let</code> &quot;destruttura&quot; or &quot;rompe&quot;
l&#39;ennupla, e assegna i suoi pezzi a tre legami.</p>

<p>Questo pattern Ã¨ molto efficace, e lo ritroveremo ripetuto in seguito.</p>

<p>Per discriminare una ennupla con un solo elemento da un valore
tra parentesi, basta usare una virgola:</p>

<span class='rusttest'>fn main() {
    (0,); // ennupla con un solo elemento
(0); // zero tra parentesi
}</span><pre class='rust rust-example-rendered'>
(<span class='number'>0</span>,); <span class='comment'>// ennupla con un solo elemento</span>
(<span class='number'>0</span>); <span class='comment'>// zero tra parentesi</span></pre>

<h2 id='indicizzazione-delle-ennuple' class='section-header'><a href='#indicizzazione-delle-ennuple'>Indicizzazione delle ennuple</a></h2>
<p>I campi di una ennupla possono essere acceduti anche con la sintassi
di indicizzazione:</p>

<span class='rusttest'>fn main() {
    let ennupla = (1, 2, 3);

let x = ennupla.0;
let y = ennupla.1;
let z = ennupla.2;

println!(&quot;x contiene {}&quot;, x);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>ennupla</span> <span class='op'>=</span> (<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>);

<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>ennupla</span>.<span class='number'>0</span>;
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='ident'>ennupla</span>.<span class='number'>1</span>;
<span class='kw'>let</span> <span class='ident'>z</span> <span class='op'>=</span> <span class='ident'>ennupla</span>.<span class='number'>2</span>;

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x contiene {}&quot;</span>, <span class='ident'>x</span>);</pre>

<p>L&#39;indicizzazione, come per gli di array, parte da zero, ma diversamente
dall&#39;indicizzazione di array, usa un carattere <code>.</code>, invece della coppia
di caratteri <code>[]</code>.</p>

<p>Per maggiori informazioni sulle ennuple si consulti <a href="../std/primitive.tuple.html">la documentazione sulla
libreria standard</a>.</p>

<h1 id='funzioni' class='section-header'><a href='#funzioni'>Funzioni</a></h1>
<p>Anche le funzioni hanno un tipo! Ecco un esempio:</p>

<span class='rusttest'>fn main() {
    fn foo(x: i32) -&gt; i32 { x }

let x: fn(i32) -&gt; i32 = foo;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='ident'>x</span> }

<span class='kw'>let</span> <span class='ident'>x</span>: <span class='kw'>fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>foo</span>;</pre>

<p>In questo caso, <code>x</code> Ã¨ un â€˜puntatore a funzioneâ€™ che punta a una funzione
che prende un <code>i32</code> e restituisce un <code>i32</code>.</p>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>