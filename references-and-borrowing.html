<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Riferimenti e prestiti</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduzione</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Come Iniziare</a>
</li>
<li><a  href='guessing-game.html'><b>3.</b> Tutorial: Gioco-indovina</a>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> Sintassi e semantica</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>4.1.</b> Legami di variabili</a>
</li>
<li><a  href='functions.html'><b>4.2.</b> Funzioni</a>
</li>
<li><a  href='primitive-types.html'><b>4.3.</b> Tipi primitivi</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> Commenti</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>4.6.</b> Cicli</a>
</li>
<li><a  href='vectors.html'><b>4.7.</b> Vettori</a>
</li>
<li><a  href='ownership.html'><b>4.8.</b> Possesso</a>
</li>
<li><a class='active' href='references-and-borrowing.html'><b>4.9.</b> Riferimenti e prestito</a>
</li>
<li><a  href='lifetimes.html'><b>4.10.</b> Tempo di vita</a>
</li>
<li><a  href='mutability.html'><b>4.11.</b> Mutabilità</a>
</li>
<li><a  href='structs.html'><b>4.12.</b> Strutture</a>
</li>
<li><a  href='enums.html'><b>4.13.</b> Enumerazioni</a>
</li>
<li><a  href='match.html'><b>4.14.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>4.15.</b> Pattern</a>
</li>
<li><a  href='method-syntax.html'><b>4.16.</b> Sintassi dei metodi</a>
</li>
<li><a  href='strings.html'><b>4.17.</b> Stringhe</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> Genericità</a>
</li>
<li><a  href='traits.html'><b>4.19.</b> Tratti</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> `if let`</a>
</li>
<li><a  href='trait-objects.html'><b>4.22.</b> Oggetti-tratti</a>
</li>
<li><a  href='closures.html'><b>4.23.</b> Chiusure</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> Sintassi universale di chiamata di funzione</a>
</li>
<li><a  href='crates-and-modules.html'><b>4.25.</b> Crate e moduli</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const` e `static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> Attributi</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> Alias tramite `type`</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> Forzatura di tipo</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> Tipi associati</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> Tipi non dimensionati</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> Operatori e sovraccaricamento</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Coercizione Deref</a>
</li>
<li><a  href='macros.html'><b>4.34.</b> Le macro</a>
</li>
<li><a  href='raw-pointers.html'><b>4.35.</b> Puntatori grezzi</a>
</li>
<li><a  href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Rust efficace</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> Lo stack e lo heap</a>
</li>
<li><a  href='testing.html'><b>5.2.</b> Collaudo</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> Compilazione condizionale</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> Documentazione</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> Iteratori</a>
</li>
<li><a  href='concurrency.html'><b>5.6.</b> Concorrenza</a>
</li>
<li><a  href='error-handling.html'><b>5.7.</b> Gestione degli errori</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> Scegliere le garanzie</a>
</li>
<li><a  href='ffi.html'><b>5.9.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> Prestito e AsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> Canali di rilascio</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> Usare Rust senza la libreria standard</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Rust notturno</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Plugin del compilatore</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Assembly in-line</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> Omettere la libreria stdandard</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinseci</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Elementi "lang"</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> Link avanzato</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Collaudi prestazionali</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Sintassi di box e relativi pattern</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Pattern di slice</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Costanti associate</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> Allocatori personalizzati</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> Glossario</a>
</li>
<li><a  href='syntax-index.html'><b>8.</b> Indice analitico della sintassi</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Riferimenti e prestiti</h1>
    <p>Questa è la seconda delle tre sezioni che presentano il sistema di possesso
di Rust. Si assume che sia già stata letta la sezione sul <a href="ownership.html">possesso</a>.</p>

<h1 id='borrowing' class='section-header'><a href='#borrowing'>Borrowing</a></h1>
<p>Alla fine della sezione sul <a href="ownership.html">possesso</a>, avevamo una brutta funzione
che si presentava così:</p>

<span class='rusttest'>fn main() {
    fn foo(v1: Vec&lt;i32&gt;, v2: Vec&lt;i32&gt;) -&gt; (Vec&lt;i32&gt;, Vec&lt;i32&gt;, i32) {
    // fa&#39; qualcosa con v1 e con v2

    // restituisci il possesso di v1 e v2, e restituisci anche
    // il risultato della nostra funzione
    (v1, v2, 42)
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];
let (v1, v2, risposta) = foo(v1, v2);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>v1</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>, <span class='ident'>v2</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> (<span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>, <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>, <span class='ident'>i32</span>) {
    <span class='comment'>// fa&#39; qualcosa con v1 e con v2</span>

    <span class='comment'>// restituisci il possesso di v1 e v2, e restituisci anche</span>
    <span class='comment'>// il risultato della nostra funzione</span>
    (<span class='ident'>v1</span>, <span class='ident'>v2</span>, <span class='number'>42</span>)
}

<span class='kw'>let</span> <span class='ident'>v1</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];
<span class='kw'>let</span> <span class='ident'>v2</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];
<span class='kw'>let</span> (<span class='ident'>v1</span>, <span class='ident'>v2</span>, <span class='ident'>risposta</span>) <span class='op'>=</span> <span class='ident'>foo</span>(<span class='ident'>v1</span>, <span class='ident'>v2</span>);</pre>

<p>Però questo non è Rust tipico, dato che non sfrutta i prestiti.
Ecco il primo passo:</p>

<span class='rusttest'>fn main() {
    fn foo(v1: &amp;Vec&lt;i32&gt;, v2: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    // fa&#39; qualcosa con v1 e con v2

    // restituisci la risposta
    42
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let risposta = foo(&amp;v1, &amp;v2);

// qui possiamo usare v1 e v2!
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>v1</span>: <span class='kw-2'>&amp;</span><span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>, <span class='ident'>v2</span>: <span class='kw-2'>&amp;</span><span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='comment'>// fa&#39; qualcosa con v1 e con v2</span>

    <span class='comment'>// restituisci la risposta</span>
    <span class='number'>42</span>
}

<span class='kw'>let</span> <span class='ident'>v1</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];
<span class='kw'>let</span> <span class='ident'>v2</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='kw'>let</span> <span class='ident'>risposta</span> <span class='op'>=</span> <span class='ident'>foo</span>(<span class='kw-2'>&amp;</span><span class='ident'>v1</span>, <span class='kw-2'>&amp;</span><span class='ident'>v2</span>);

<span class='comment'>// qui possiamo usare v1 e v2!</span></pre>

<p>Un esempio più concreto:</p>

<span class='rusttest'>fn main() {
    // Non importa se non si capisce cosa fa `fold`, quello che importa
    // qui è che un riferimento immutabile viene preso in prestito.
    fn somma_vec(v: &amp;Vec&lt;i32&gt;) -&gt; i32 {
        return v.iter().fold(0, |a, &amp;b| a + b);
    }
    // Prendi in prestito due vettori e sommane gli elementi.
    // Questo tipo di prestito non permette che gli oggetti siano mutati.
    fn foo(v1: &amp;Vec&lt;i32&gt;, v2: &amp;Vec&lt;i32&gt;) -&gt; i32 {
        // fa&#39; qualcosa con v1 e con v2
        let s1 = somma_vec(v1);
        let s2 = somma_vec(v2);
        // restituisci la risposta
        s1 + s2
    }

    let v1 = vec![1, 2, 3];
    let v2 = vec![4, 5, 6];

    let risposta = foo(&amp;v1, &amp;v2);
    println!(&quot;{}&quot;, risposta);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='comment'>// Non importa se non si capisce cosa fa `fold`, quello che importa</span>
    <span class='comment'>// qui è che un riferimento immutabile viene preso in prestito.</span>
    <span class='kw'>fn</span> <span class='ident'>somma_vec</span>(<span class='ident'>v</span>: <span class='kw-2'>&amp;</span><span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
        <span class='kw'>return</span> <span class='ident'>v</span>.<span class='ident'>iter</span>().<span class='ident'>fold</span>(<span class='number'>0</span>, <span class='op'>|</span><span class='ident'>a</span>, <span class='kw-2'>&amp;</span><span class='ident'>b</span><span class='op'>|</span> <span class='ident'>a</span> <span class='op'>+</span> <span class='ident'>b</span>);
    }
    <span class='comment'>// Prendi in prestito due vettori e sommane gli elementi.</span>
    <span class='comment'>// Questo tipo di prestito non permette che gli oggetti siano mutati.</span>
    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>v1</span>: <span class='kw-2'>&amp;</span><span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>, <span class='ident'>v2</span>: <span class='kw-2'>&amp;</span><span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
        <span class='comment'>// fa&#39; qualcosa con v1 e con v2</span>
        <span class='kw'>let</span> <span class='ident'>s1</span> <span class='op'>=</span> <span class='ident'>somma_vec</span>(<span class='ident'>v1</span>);
        <span class='kw'>let</span> <span class='ident'>s2</span> <span class='op'>=</span> <span class='ident'>somma_vec</span>(<span class='ident'>v2</span>);
        <span class='comment'>// restituisci la risposta</span>
        <span class='ident'>s1</span> <span class='op'>+</span> <span class='ident'>s2</span>
    }

    <span class='kw'>let</span> <span class='ident'>v1</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];
    <span class='kw'>let</span> <span class='ident'>v2</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>4</span>, <span class='number'>5</span>, <span class='number'>6</span>];

    <span class='kw'>let</span> <span class='ident'>risposta</span> <span class='op'>=</span> <span class='ident'>foo</span>(<span class='kw-2'>&amp;</span><span class='ident'>v1</span>, <span class='kw-2'>&amp;</span><span class='ident'>v2</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>risposta</span>);
}</pre>

<p>Invece di prendere dei <code>Vec&lt;i32&gt;</code> come argomenti, prendiamo dei riferimenti:
<code>&amp;Vec&lt;i32&gt;</code>. E invece di passare <code>v1</code> e <code>v2</code> direttamente, passiamo <code>&amp;v1</code> e
<code>&amp;v2</code>. Il tipo <code>&amp;T</code> viene chiamato ‘riferimento’, e invece di possedere
la risorsa, ne prende in prestito il possesso. Un legame che prende in prestito
qualche oggetto non dealloca quella risorsa quando esce dall&#39;ambito.
Ciò significa che dopo la chiamata a <code>foo()</code>, possiamo usare ancora i nostri
legami originali.</p>

<p>I riferimenti sono immutabile, come i legami. Ciò significa che dentro <code>foo()</code>,
i due vettori non possono affatto essere modificati:</p>

<span class='rusttest'>fn main() {
    fn foo(v: &amp;Vec&lt;i32&gt;) {
     v.push(5);
}

let v = vec![];

foo(&amp;v);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>v</span>: <span class='kw-2'>&amp;</span><span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>) {
     <span class='ident'>v</span>.<span class='ident'>push</span>(<span class='number'>5</span>);
}

<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[];

<span class='ident'>foo</span>(<span class='kw-2'>&amp;</span><span class='ident'>v</span>);</pre>

<p>ci darà questo errore:</p>

<pre><code class="language-text">error: cannot borrow immutable borrowed content `*v` as mutable
v.push(5);
^
</code></pre>

<p>Aggiungere un valore (chiamando <code>push</code>) muterebbe il vettore, e quindi non
ci viene permesso.</p>

<h1 id='i-riferimenti-mut' class='section-header'><a href='#i-riferimenti-mut'>I riferimenti &amp;mut</a></h1>
<p>C&#39;è un altro tipo di riferimenti: <code>&amp;mut T</code>. Un ‘riferimento mutabile’ permette
di mutare la risorsa che viene presa in prestito. Per esempio:</p>

<span class='rusttest'>fn main() {
    let mut x = 5;
{
    let y = &amp;mut x;
    *y += 1;
}
println!(&quot;{}&quot;, x);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
{
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>x</span>;
    <span class='op'>*</span><span class='ident'>y</span> <span class='op'>+=</span> <span class='number'>1</span>;
}
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);</pre>

<p>Questo stamperà <code>6</code>. Abbiamo creato <code>y</code> come riferimento mutabile a <code>x</code>, e poi
abbiamo incrementato l&#39;oggetto a cui <code>y</code> punta. Si noterà che abbiamo dovuto
marcare anche <code>x</code> come <code>mut</code>.
Se non l&#39;avessimo fatto, non avremmo potuto prendere in prestito mutabile
un valore immutabile.</p>

<p>Si noterà anche che abbiamo aggiunto un asterisco (<code>*</code>) prima di <code>y</code>,
rendendolo <code>*y</code>.  Questo è necessario perché <code>y</code> è un riferimento. Se deve
usare un asterisco per accedere al contenuto di un riferimento, che sia
mutabile o immutabile.</p>

<p>I riferimenti <code>&amp;mut</code> somigliano ai riferimenti; però, c&#39;_è_ una grossa
differenza tra i due, e su come interagiscono. Si potrebbe dire che
nell&#39;esempio qui sopra ci sono due graffe di troppo, che racchiudono l&#39;ambito
di <code>y</code>. Ma se le togliamo, otteniamo un errore:</p>

<pre><code class="language-text">error: cannot borrow `x` as immutable because it is also borrowed as mutable
    println!(&quot;{}&quot;, x);
                   ^
note: previous borrow of `x` occurs here; the mutable borrow prevents
subsequent moves, borrows, or modification of `x` until the borrow ends
        let y = &amp;mut x;
                     ^
note: previous borrow ends here
fn main() {

}
^
</code></pre>

<p>Da quel che risulta, ci sono regole da rispettare.</p>

<h1 id='le-regole' class='section-header'><a href='#le-regole'>Le regole</a></h1>
<p>Ecco le regole per prendere a prestito in Rust:</p>

<p>Primo, ogni prestito deve durare per un ambito non più esteso di quello
del possessore. Secondo, si può avere uno o l&#39;altro dei due seguenti generi
di prestiti, ma non entrambi allo stesso tempo:</p>

<ul>
<li>uno o più riferimenti non mutabili (<code>&amp;T</code>) a un oggetto,</li>
<li>esattamente un riferimento mutabile (<code>&amp;mut T</code>) a un oggetto.</li>
</ul>

<p>Questa regola è molto simile, anche se non esattamente uguale,
alla definizione di &#39;corsa ai dati&#39; [&quot;data race&quot;]:</p>

<blockquote>
<p>C&#39;è una ‘corsa ai dati’ quando due o più puntatori accedono alla medesima
posizione di memoria nello stesso tempo, e per almeno uno di essi tale
accesso è in scrittura, e tali accessi non sono sincronizzati.</p>
</blockquote>

<p>Per quanto riguarda i riferimenti immutabili, se ne possono avere quanti se ne
vogliono, dato che nessuno di essi sta scrivendo. Però, dato possiamo avere
solamente un riferimenti mutabili per volta, è impossibile avere una corsa
ai dati. Questa tecnica consente a Rust in fase di compilazione di prevenire
le corse ai dati: otterremmo degli errori se violiamo le regole.</p>

<p>Tenendo questo a mente, consideriamo ancora il nostro esempio.</p>

<h2 id='pensare-secondo-gli-ambiti' class='section-header'><a href='#pensare-secondo-gli-ambiti'>Pensare secondo gli ambiti</a></h2>
<p>Ecco il codice:</p>

<span class='rusttest'>fn main() {
    let mut x = 5;
    let y = &amp;mut x;

    *y += 1;

    println!(&quot;{}&quot;, x);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>x</span>;

    <span class='op'>*</span><span class='ident'>y</span> <span class='op'>+=</span> <span class='number'>1</span>;

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);
}</pre>

<p>Questo codice ci dà questo errore:</p>

<pre><code class="language-text">error: cannot borrow `x` as immutable because it is also borrowed as mutable
    println!(&quot;{}&quot;, x);
                   ^
</code></pre>

<p>Questo perché abbiamo violate le regole: abbiamo un <code>&amp;mut T</code> che punta a <code>x</code>,
e così non ci è permesso creare dei <code>&amp;T</code> che puntino al medesimo oggetto.
È l&#39;uno o l&#39;altro. L&#39;annotazione suggerisce come pensare a questo problema:</p>

<pre><code class="language-text">note: previous borrow ends here
fn main() {

}
^
</code></pre>

<p>In altre parole, il prestito mutabile viene tenuto per tutto il resto
del programma. Ciò che vogliamo è che il prestito mutable a <code>y</code> finisca, così
che la risorsa possa essere restituita al possessore, <code>x</code>. Poi <code>x</code> può fornire
un prestito immutabile a <code>println!</code>. In Rust, prendere a prestito è legato
all&#39;ambito per cui il prestito è valido. E il nostro ambito si presenta così:</p>

<span class='rusttest'>fn main() {
    let mut x = 5;

    let y = &amp;mut x;    // -+ qui inizia il prestito mutabile di x 
                       //  |
    *y += 1;           //  |
                       //  |
    println!(&quot;{}&quot;, x); // -+ - qui prova a prendere a prestito immutabile x
}                      // -+ qui finisce il prestito mutabile di x
                       
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;

    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>x</span>;    <span class='comment'>// -+ qui inizia il prestito mutabile di x </span>
                       <span class='comment'>//  |</span>
    <span class='op'>*</span><span class='ident'>y</span> <span class='op'>+=</span> <span class='number'>1</span>;           <span class='comment'>//  |</span>
                       <span class='comment'>//  |</span>
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>); <span class='comment'>// -+ - qui prova a prendere a prestito immutabile x</span>
}                      <span class='comment'>// -+ qui finisce il prestito mutabile di x</span>
                       </pre>

<p>Gli ambiti sono in conflitto: non possiamo fare un <code>&amp;x</code> mentre <code>y</code> è
nell&#39;ambito.</p>

<p>Perciò quando aggiungiamo le graffe:</p>

<span class='rusttest'>fn main() {
    let mut x = 5;

{
    let y = &amp;mut x; // -+ qui inizia il prestito mutabile
    *y += 1;        //  |
}                   // -+ ... e qui finisce

println!(&quot;{}&quot;, x);  // &lt;- qui prova a prendere a prestito immutabile x
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;

{
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>x</span>; <span class='comment'>// -+ qui inizia il prestito mutabile</span>
    <span class='op'>*</span><span class='ident'>y</span> <span class='op'>+=</span> <span class='number'>1</span>;        <span class='comment'>//  |</span>
}                   <span class='comment'>// -+ ... e qui finisce</span>

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);  <span class='comment'>// &lt;- qui prova a prendere a prestito immutabile x</span></pre>

<p>Non c&#39;è problema. Il nostro prestito mutabile esce di ambito prima che venga
creato quello immutabile. Perciò l&#39;ambito è la chiave per vedere quanto dura
un prestito.</p>

<h2 id='difetti-prevenuti-dai-prestiti' class='section-header'><a href='#difetti-prevenuti-dai-prestiti'>Difetti prevenuti dai prestiti</a></h2>
<p>Perché ci sono queste regole restrittive? Beh, come abbiamo detto,
queste regole prevengono le corse ai dati. Le corse ai dati che genere
di difetti provocano? Ecconi alcuni.</p>

<h3 id='invalidazione-degli-iteratori' class='section-header'><a href='#invalidazione-degli-iteratori'>Invalidazione degli iteratori</a></h3>
<p>Un esempio è l&#39;‘invalidazione degli iteratori’, che avviene quando si prova
a mutare una collezione su cui si sta iterando. Il verificatore dei prestiti
di Rust previene che accada:</p>

<span class='rusttest'>fn main() {
    let mut v = vec![1, 2, 3];

for i in &amp;v {
    println!(&quot;{}&quot;, i);
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='kw'>for</span> <span class='ident'>i</span> <span class='kw'>in</span> <span class='kw-2'>&amp;</span><span class='ident'>v</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>i</span>);
}</pre>

<p>Questo codice stampa i numeri da uno a tre. Mentre iteriamo lungo il vettore,
ci vengono dati solamente dei riferimenti agli elementi. E <code>v</code> è esso stesso
preso in prestito come immutabile, il che significa che non possiamo cambiarlo
mentre stiamo iterando:</p>

<span class='rusttest'>fn main() {
    let mut v = vec![1, 2, 3];

for i in &amp;v {
    println!(&quot;{}&quot;, i);
    v.push(34);
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='kw'>for</span> <span class='ident'>i</span> <span class='kw'>in</span> <span class='kw-2'>&amp;</span><span class='ident'>v</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>i</span>);
    <span class='ident'>v</span>.<span class='ident'>push</span>(<span class='number'>34</span>);
}</pre>

<p>Ecco l&#39;errore:</p>

<pre><code class="language-text">error: cannot borrow `v` as mutable because it is also borrowed as immutable
    v.push(34);
    ^
note: previous borrow of `v` occurs here; the immutable borrow prevents
subsequent moves or mutable borrows of `v` until the borrow ends
for i in &amp;v {
          ^
note: previous borrow ends here
for i in &amp;v {
    println!(“{}”, i);
    v.push(34);
}
^
</code></pre>

<p>Non possiamo modificare <code>v</code> perché è preso in prestito dal ciclo.</p>

<h3 id='uso-dopo-il-rilascio' class='section-header'><a href='#uso-dopo-il-rilascio'>Uso dopo il rilascio</a></h3>
<p>I riferimenti non devono vivere più a lungo dell&#39;oggetto a cui fanno
riferimento. Rust verificherà gli ambiti dei riferimenti per assicurare
che sia così.</p>

<p>Se Rust non verificasse questa proprietà, potremmo accidentalmente usare
un oggetto che è diventato invalido. Per esempio:</p>

<span class='rusttest'>fn main() {
    let y: &amp;i32;
{
    let x = 5;
    y = &amp;x;
}

println!(&quot;{}&quot;, y);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>y</span>: <span class='kw-2'>&amp;</span><span class='ident'>i32</span>;
{
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
    <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>x</span>;
}

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>y</span>);</pre>

<p>Otteniamo questo errore:</p>

<pre><code class="language-text">error: `x` does not live long enough
    y = &amp;x;
         ^
note: reference must be valid for the block suffix following statement 0 at
2:16...
let y: &amp;i32;
{
    let x = 5;
    y = &amp;x;
}

note: ...but borrowed value is only valid for the block suffix following
statement 0 at 4:18
    let x = 5;
    y = &amp;x;
}
</code></pre>

<p>In altre parole, il valore di <code>y</code> è valido solamente per l&#39;ambito dove <code>x</code>
esiste. Non appena <code>x</code> se ne va, diventa invalido fare riferimento ad esso.
Come tale, l&#39;errore dice che il prestito ‘non vive abbastanza a lungo’ perché
non è valido per la giusta quantità di tempo.</p>

<p>Il medesimo problema avviene quando il riferimento è dichiarato <em>prima</em>
della variabile a cui si riferisce. Questo è devuto al fatto che le risorse
entro lo stesso ambito vengono rilasciate nell&#39;ordine inverso di quello
con cui sono state acquisite:</p>

<span class='rusttest'>fn main() {
    let y: &amp;i32;
let x = 5;
y = &amp;x;

println!(&quot;{}&quot;, y);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>y</span>: <span class='kw-2'>&amp;</span><span class='ident'>i32</span>;
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>x</span>;

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>y</span>);</pre>

<p>Otteniamo questo errore:</p>

<pre><code class="language-text">error: `x` does not live long enough
y = &amp;x;
     ^
note: reference must be valid for the block suffix following statement 0 at
2:16...
    let y: &amp;i32;
    let x = 5;
    y = &amp;x;

    println!(&quot;{}&quot;, y);
}

note: ...but borrowed value is only valid for the block suffix following
statement 1 at 3:14
    let x = 5;
    y = &amp;x;

    println!(&quot;{}&quot;, y);
}
</code></pre>

<p>Nell&#39;esempio qui sopra, <code>y</code> è dichiarato prima di <code>x</code>, il che comporta che <code>y</code>
vive (leggermente) più a lungo di <code>x</code>, il che non è consentito.</p>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>