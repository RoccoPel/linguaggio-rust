<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Le macro</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduzione</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Come Iniziare</a>
</li>
<li><a  href='guessing-game.html'><b>3.</b> Tutorial: Gioco-indovina</a>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> Sintassi e semantica</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>4.1.</b> Legami di variabili</a>
</li>
<li><a  href='functions.html'><b>4.2.</b> Funzioni</a>
</li>
<li><a  href='primitive-types.html'><b>4.3.</b> Tipi primitivi</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> Commenti</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>4.6.</b> Cicli</a>
</li>
<li><a  href='vectors.html'><b>4.7.</b> Vettori</a>
</li>
<li><a  href='ownership.html'><b>4.8.</b> Possesso</a>
</li>
<li><a  href='references-and-borrowing.html'><b>4.9.</b> Riferimenti e prestito</a>
</li>
<li><a  href='lifetimes.html'><b>4.10.</b> Tempo di vita</a>
</li>
<li><a  href='mutability.html'><b>4.11.</b> Mutabilità</a>
</li>
<li><a  href='structs.html'><b>4.12.</b> Strutture</a>
</li>
<li><a  href='enums.html'><b>4.13.</b> Enumerazioni</a>
</li>
<li><a  href='match.html'><b>4.14.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>4.15.</b> Pattern</a>
</li>
<li><a  href='method-syntax.html'><b>4.16.</b> Sintassi dei metodi</a>
</li>
<li><a  href='strings.html'><b>4.17.</b> Stringhe</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> Genericità</a>
</li>
<li><a  href='traits.html'><b>4.19.</b> Tratti</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> `if let`</a>
</li>
<li><a  href='trait-objects.html'><b>4.22.</b> Oggetti-tratti</a>
</li>
<li><a  href='closures.html'><b>4.23.</b> Chiusure</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> Sintassi universale di chiamata di funzione</a>
</li>
<li><a  href='crates-and-modules.html'><b>4.25.</b> Crate e moduli</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const` e `static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> Attributi</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> Alias tramite `type`</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> Forzatura di tipo</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> Tipi associati</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> Tipi non dimensionati</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> Operatori e sovraccaricamento</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Coercizione Deref</a>
</li>
<li><a class='active' href='macros.html'><b>4.34.</b> Le macro</a>
</li>
<li><a  href='raw-pointers.html'><b>4.35.</b> Puntatori grezzi</a>
</li>
<li><a  href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Rust efficace</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> Lo stack e lo heap</a>
</li>
<li><a  href='testing.html'><b>5.2.</b> Collaudo</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> Compilazione condizionale</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> Documentazione</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> Iteratori</a>
</li>
<li><a  href='concurrency.html'><b>5.6.</b> Concorrenza</a>
</li>
<li><a  href='error-handling.html'><b>5.7.</b> Gestione degli errori</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> Scegliere le garanzie</a>
</li>
<li><a  href='ffi.html'><b>5.9.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> Prestito e AsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> Canali di rilascio</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> Usare Rust senza la libreria standard</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Rust notturno</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Plugin del compilatore</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Assembly in-line</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> Omettere la libreria stdandard</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinseci</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Elementi "lang"</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> Link avanzato</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Collaudi prestazionali</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Sintassi di box e relativi pattern</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Pattern di slice</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Costanti associate</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> Allocatori personalizzati</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> Glossario</a>
</li>
<li><a  href='syntax-index.html'><b>8.</b> Indice analitico della sintassi</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Le macro</h1>
    <p>Abbiamo già visto molti degli strumenti forniti da Rust per creare astrazioni e
per riutilizzare il codice. Queste unità di riuso del codice hanno una ricca
struttura semantica. Per esempio, le funzioni hanno una firma di tipo,
i parametri di tipo hanno dei legami di tratti, e le funzioni sovraccaricate
devono appartenere a un particolare tratto.</p>

<p>Questa struttura significa che le astrazioni del nucleo di Rust hanno
potenti verifiche di correttezza in fase di compilazione. Ma questo si paga
con una ridotta flessibilit. Se si identifica visivamente un pattern di codice
ripetuto, si può trovare difficile o contorto esprimere quel pattern come
funzione generica, tratto, qualcos&#39;altro entro la semantica di Rust.</p>

<p>Le macro ci consentono di astrarre a livello sintattico. Un&#39;invocazione
di macro è un&#39;abbreviazione di una forma sintattica &quot;espansa&quot;. Questa
espansione avviene nelle fasi iniziali della compilazione, prima di ogni
verifica statica. Di conseguenza, le macro possono catturare molti pattern
di riutilizzo del codice che le astrazioni del nucleo di Rust non possono.</p>

<p>Lo svantaggio è che il codice basato su macro può essere più difficile
da capire harder, perché poche delle regole incorporate si applicano. Come
le normali funzione, le macro che si comportano bene possono essere usate senza
dover capire come sono implementate. Però, può essere difficile progettare
una macro che si comporta bene! Inoltre, gli errori di compilazione nel codice
che usa macro sono più difficili da capire, perché descrivono errori nel codice
espanso, non nella forma sorgente scritta dagli sviluppatori.</p>

<p>Questi svantaggi rendono le macro qualcosa come &quot;caratteristiche da ultima
spiaggia&quot;. Ciò non vuol dire che le macro vanno evitate; fanno parte di Rust
perché talvolta servono per scrivere del codice molto conciso e astratto.
Si deve solo tenere a mente di questi pro e contro.</p>

<h1 id='definire-una-macro' class='section-header'><a href='#definire-una-macro'>Definire una macro</a></h1>
<p>Si avrà già visto la macro <code>vec!</code>, usata per inizializzare un <a href="vectors.html">vettore</a> con una lista di elementi specificati.</p>

<span class='rusttest'>fn main() {
    let x: Vec&lt;u32&gt; = vec![1, 2, 3];
assert_eq!(x, [1, 2, 3]);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u32</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];</pre>

<p>Questa non può essere una normale funzione, perché prende un numero variabile
di argomenti. Ma la possiamo immaginare come abbreviazione sintattica di:</p>

<span class='rusttest'>fn main() {
    let x: Vec&lt;u32&gt; = {
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
};
assert_eq!(x, [1, 2, 3]);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u32</span><span class='op'>&gt;</span> <span class='op'>=</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>temp_vec</span> <span class='op'>=</span> <span class='ident'>Vec</span>::<span class='ident'>new</span>();
    <span class='ident'>temp_vec</span>.<span class='ident'>push</span>(<span class='number'>1</span>);
    <span class='ident'>temp_vec</span>.<span class='ident'>push</span>(<span class='number'>2</span>);
    <span class='ident'>temp_vec</span>.<span class='ident'>push</span>(<span class='number'>3</span>);
    <span class='ident'>temp_vec</span>
};</pre>

<p>Possiamo implementare questa abbreviazione, usando una macro: <sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup></p>

<span class='rusttest'>macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
fn main() {
    assert_eq!(vec![1,2,3], [1, 2, 3]);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>vec</span> {
    ( $( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span> ),<span class='op'>*</span> ) <span class='op'>=&gt;</span> {
        {
            <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>temp_vec</span> <span class='op'>=</span> <span class='ident'>Vec</span>::<span class='ident'>new</span>();
            $(
                <span class='ident'>temp_vec</span>.<span class='ident'>push</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>);
            )<span class='op'>*</span>
            <span class='ident'>temp_vec</span>
        }
    };
}</pre>

<p>Urca, c&#39;è un sacco di sintassi nuova! Analizziamola.</p>

<span class='rusttest'>fn main() {
    macro_rules! vec { ... }
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>vec</span> { ... }</pre>

<p>Questo dice che stiamo definendo una macro chiamata <code>vec</code>, come <code>fn vec</code>
definirebbe una funzione chiamata <code>vec</code>. Quando si invoca una macro, il nome
della macro è seguito da un punto esclamativo, per es. <code>vec!</code>. Il punto
esclamativo fa parte della sintassi di invocazione e serve a distinguere
una macro da una normale funzione.</p>

<h2 id='pattern-matching' class='section-header'><a href='#pattern-matching'>Pattern-matching</a></h2>
<p>La macro viene definita tramite una serie di regole, che sono casi
di pattern-matching. Sopra, avevamo</p>

<span class='rusttest'>fn main() {
    ( $( $x:expr ),* ) =&gt; { ... };
}</span><pre class='rust rust-example-rendered'>
( $( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span> ),<span class='op'>*</span> ) <span class='op'>=&gt;</span> { ... };</pre>

<p>Questo è simile a un braccio di un&#39;espressione <code>match</code>, ma la corrispondenza
avviene con gli alberi sintattici di Rust, in fase di compilazione.
Il punto-e-virgola dopo l&#39;ultimo caso (che qui è anche l&#39;unico) è facoltativo.
Il &quot;pattern&quot; sul lato sinistro di <code>=&gt;</code> è noto come ‘matcher’. Queste
espressioni hanno <a href="../reference.html#macros">la loro piccola grammatica</a> all&#39;interno del linguaggio.</p>

<p>Il matcher <code>$x:expr</code> combacierà con qualunque espressione Rust, legando
quell&#39;albero sintattico alla ‘metavariabile’ <code>$x</code>. L&#39;identificatore <code>expr</code> è
uno ‘specificatore di frammento’; le possibilità complete verranno elencate
più avanti in questa sezione.
Circondando il matcher con <code>$(...),*</code> significa che potranno combaciare
nessuna o alcune espressioni, separate da virgole.</p>

<p>A parte la speciale sintassi del matcher, ogni token Rust che appare in
un matcher deve combaciare esattamente. Per esempio,</p>

<span class='rusttest'>macro_rules! foo {
    (x =&gt; $e:expr) =&gt; (println!(&quot;modalità X: {}&quot;, $e));
    (y =&gt; $e:expr) =&gt; (println!(&quot;modalità Y: {}&quot;, $e));
}

fn main() {
    foo!(y =&gt; 3);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>foo</span> {
    (<span class='ident'>x</span> <span class='op'>=&gt;</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> (<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;modalità X: {}&quot;</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>));
    (<span class='ident'>y</span> <span class='op'>=&gt;</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> (<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;modalità Y: {}&quot;</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>));
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>foo</span><span class='macro'>!</span>(<span class='ident'>y</span> <span class='op'>=&gt;</span> <span class='number'>3</span>);
}</pre>

<p>stamperà</p>

<pre><code class="language-text">modalità Y: 3
</code></pre>

<p>Con</p>

<span class='rusttest'>fn main() {
    foo!(z =&gt; 3);
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>foo</span><span class='macro'>!</span>(<span class='ident'>z</span> <span class='op'>=&gt;</span> <span class='number'>3</span>);</pre>

<p>otterremo un errore di compilazione</p>

<pre><code class="language-text">error: no rules expected the token `z`
</code></pre>

<h2 id='espansione' class='section-header'><a href='#espansione'>Espansione</a></h2>
<p>Il lato destro di una regola di macro è normale sintassi Rust, per lo più.
Ma possiamo innestare pezzetti della sintassi catturata dal matcher.
Dall&#39;esempio originale:</p>

<span class='rusttest'>fn main() {
    $(
    temp_vec.push($x);
)*
}</span><pre class='rust rust-example-rendered'>
$(
    <span class='ident'>temp_vec</span>.<span class='ident'>push</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>);
)<span class='op'>*</span></pre>

<p>Ogni espressione combaciante <code>$x</code> produrrà una singola istruzione <code>push</code>
nell&#39;espansione della macro. La ripetizione dell&#39;espansione procede di pari
passo con la ripetizione del matcher (fra poco ne diremo di più).</p>

<p>Siccome <code>$x</code> era già stata dichiarata come combaciante un&#39;espressione, non si
ripete <code>:expr</code> sul lato destro. Inoltre, non si aggiunge una virgola
di separazione come parte dell&#39;operatore di ripetizione. Invece, si mette
il punto-e-virgola di terminazione all&#39;interno del blocco ripetuto.</p>

<p>Un altro dettaglio: la macro <code>vec!</code> ha <em>due</em> coppie di graffe sul lato destro.
Vengono spesso combinate così:</p>

<span class='rusttest'>fn main() {
    macro_rules! foo {
    () =&gt; {{
        ...
    }}
}
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>foo</span> {
    () <span class='op'>=&gt;</span> {{
        ...
    }}
}</pre>

<p>Le graffe esterne fanno parte della sintassi di <code>macro_rules!</code>. Di fatto,
si può usare <code>()</code> o <code>[]</code> invece. Delimitano semplicemente il lato destro
nel suo insieme.</p>

<p>Le graffe interne fanno parte della sintassi espansa. Si ricordi che la macro
<code>vec!</code> va usata in un contesto di espressione. Per scrivere un&#39;espressione
contenente più istruzioni, tra cui delle istruzioni <code>let</code>, si deve usare
un blocco. Se invece si scrive una macro che si espande a una singola
espressione, non c&#39;è bisogno di queste graffe ulteriori.</p>

<p>Si noti che non abbiamo mai <em>dichiarato</em> che la macro produce un&#39;espressione.
Infatti, questo non è determinato fino a quando usiamo la macro
come espressione. Con attenzione, si può scrivere una macro la cui espansione
funziona in più contesti. Per esempio, un&#39;abbreviazione di un tipo di dati
potrebbe essere valida sia come espressione che come pattern.</p>

<h2 id='ripetizione' class='section-header'><a href='#ripetizione'>Ripetizione</a></h2>
<p>L&#39;operatore di ripetizione segue due regole principali:</p>

<ol>
<li><code>$(...)*</code> percorre uno &quot;strato&quot; di ripetizioni, per ogni <code>$nome</code> che
contiene, di pari passo, e</li>
<li>ogni <code>$nome</code> deve essere sotto almeno tanti <code>$(...)*</code> quanti sono quelli
con cui ha combaciato. Se è sotto a un numero maggiore, verrà
appropriatamente duplicato.</li>
</ol>

<p>La seguente macro barocca illustra la duplicazione di variabili
da livelli esterni di ripetizione.</p>

<span class='rusttest'>macro_rules! o_O {
    (
        $(
            $x:expr; [ $( $y:expr ),* ]
        );*
    ) =&gt; {
        &amp;[ $($( $x + $y ),*),* ]
    }
}

fn main() {
    let a: &amp;[i32]
        = o_O!(10; [1, 2, 3];
               20; [4, 5, 6]);

    assert_eq!(a, [11, 12, 13, 24, 25, 26]);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>o_O</span> {
    (
        $(
            <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span>; [ $( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>y</span>:<span class='ident'>expr</span> ),<span class='op'>*</span> ]
        );<span class='op'>*</span>
    ) <span class='op'>=&gt;</span> {
        <span class='kw-2'>&amp;</span>[ $($( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span> <span class='op'>+</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>y</span> ),<span class='op'>*</span>),<span class='op'>*</span> ]
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>a</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>i32</span>]
        <span class='op'>=</span> <span class='macro'>o_O</span><span class='macro'>!</span>(<span class='number'>10</span>; [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];
               <span class='number'>20</span>; [<span class='number'>4</span>, <span class='number'>5</span>, <span class='number'>6</span>]);

    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>a</span>, [<span class='number'>11</span>, <span class='number'>12</span>, <span class='number'>13</span>, <span class='number'>24</span>, <span class='number'>25</span>, <span class='number'>26</span>]);
}</pre>

<p>Questa è la sintassi più comune del matcher. Questi esempi usano <code>$(...)*</code>,
che è un combaciamento di tipo &quot;nessuno o alcuni&quot;. Alternativamente si può
scrivere <code>$(...)+</code> per un combaciamento di tipo &quot;uno o alcuni&quot;. Entrambe
le forme comprendono un separatore facoltativo, che può essere qualunque token
eccetto <code>+</code> o <code>*</code>.</p>

<p>Questo sistema si pasa su
&quot;<a href="https://www.cs.indiana.edu/ftp/techreports/TR206.pdf">Macro-by-Example</a>&quot;
(collegamento a file PDF).</p>

<h1 id='igiene' class='section-header'><a href='#igiene'>Igiene</a></h1>
<p>Alcuni linguaggi implementano macro usando semplici sostituzioni di testo,
il che comporta vari svantaggi. Per esempio, questo programma C stampa <code>13</code>
invece dell&#39;atteso <code>25</code>.</p>

<pre><code class="language-text">#define PER_CINQUE(x) 5 * x

int main() {
    printf(&quot;%d\n&quot;, PER_CINQUE(2 + 3));
    return 0;
}
</code></pre>

<p>Dopo l&#39;espansione abbiamo <code>5 * 2 + 3</code>, e la moltiplicazione ha la precedenza
sull&#39;addizione. Chi avesse usato molto le macro del C, probabilmente conosce
le tecniche standard per evitare questo difetto, e così pure cinque o sei
altri. In Rust, non dobbiamo preoccuparcene.</p>

<span class='rusttest'>macro_rules! per_cinque {
    ($x:expr) =&gt; (5 * $x);
}

fn main() {
    assert_eq!(25, per_cinque!(2 + 3));
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>per_cinque</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> (<span class='number'>5</span> <span class='op'>*</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>);
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>25</span>, <span class='macro'>per_cinque</span><span class='macro'>!</span>(<span class='number'>2</span> <span class='op'>+</span> <span class='number'>3</span>));
}</pre>

<p>La metavariabile <code>$x</code> viene analizzata dal parser come singola espressione, e
mantiene il suo posto nell&#39;albero sintattico anche dopo la sostituzione.</p>

<p>Un altro difetto tipico dei sistemi di macro è la ‘cattura di variabile’. Ecco
una macro C, che usa [una estensione del GNU C] per emulare i blocchi
di espressione di Rust.</p>

<pre><code class="language-text">#define LOG(msg) ({ \
    int state = get_log_state(); \
    if (state &gt; 0) { \
        printf(&quot;log(%d): %s\n&quot;, state, msg); \
    } \
})
</code></pre>

<p>Ecco un semplice caso d&#39;uso che che funziona malissimo:</p>

<pre><code class="language-text">const char *state = &quot;reticulating splines&quot;;
LOG(state)
</code></pre>

<p>Questo si espande in</p>

<pre><code class="language-text">const char *state = &quot;reticulating splines&quot;;
{
    int state = get_log_state();
    if (state &gt; 0) {
        printf(&quot;log(%d): %s\n&quot;, state, state);
    }
}
</code></pre>

<p>La seconda variabile chiamata <code>state</code> oscura la prima. Questo è un difetto
perché l&#39;istruzione printf dovrebbe riferirsi a entrambe.</p>

<p>L&#39;equivalente macro di Rust ha il comportamento desiderato.</p>

<span class='rusttest'>fn get_log_state() -&gt; i32 { 3 }
macro_rules! log {
    ($msg:expr) =&gt; {{
        let state: i32 = get_log_state();
        if state &gt; 0 {
            println!(&quot;log({}): {}&quot;, state, $msg);
        }
    }};
}

fn main() {
    let state: &amp;str = &quot;reticulating splines&quot;;
    log!(state);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>log</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>msg</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> {{
        <span class='kw'>let</span> <span class='ident'>state</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>get_log_state</span>();
        <span class='kw'>if</span> <span class='ident'>state</span> <span class='op'>&gt;</span> <span class='number'>0</span> {
            <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;log({}): {}&quot;</span>, <span class='ident'>state</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>msg</span>);
        }
    }};
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>state</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span> <span class='op'>=</span> <span class='string'>&quot;reticulating splines&quot;</span>;
    <span class='macro'>log</span><span class='macro'>!</span>(<span class='ident'>state</span>);
}</pre>

<p>Questa funziona perché Rust ha un <a href="https://en.wikipedia.org/wiki/Hygienic_macro">sistema igienico di macro</a>. Ogni espansione
di macro avviene in un ‘contesto sintattico’ distinto, e ogni variabile viene
etichettata con il contesto sintattico in cui è stata introdotta. È come se la
variabile <code>state</code> dentro <code>main</code> fosse dipinta di un diverso &quot;colore&quot; rispetto
alla variabile <code>state</code> interna alla macro, e perciò non entrano in conflitto.</p>

<p>Ciò restringe anche la capacità delle macros di introdurre nuovi legami
al punto di invocazione. Del codice come l seguente non funzionerà:</p>

<span class='rusttest'>macro_rules! foo {
    () =&gt; (let x = 3;);
}

fn main() {
    foo!();
    println!(&quot;{}&quot;, x);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>foo</span> {
    () <span class='op'>=&gt;</span> (<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>3</span>;);
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>foo</span><span class='macro'>!</span>();
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);
}</pre>

<p>Invece, bisogna passare il nome della variabile all&#39;invocazione, così che
sia etichettata con il giusto contesto sintattico.</p>

<span class='rusttest'>macro_rules! foo {
    ($v:ident) =&gt; (let $v = 3;);
}

fn main() {
    foo!(x);
    println!(&quot;{}&quot;, x);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>foo</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>v</span>:<span class='ident'>ident</span>) <span class='op'>=&gt;</span> (<span class='kw'>let</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>v</span> <span class='op'>=</span> <span class='number'>3</span>;);
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>foo</span><span class='macro'>!</span>(<span class='ident'>x</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);
}</pre>

<p>Questo vale per i legami <code>let</code> e le etichette dei cicli, ma non per
gli <a href="../reference.html#items">elementi</a>. Quindi il seguente codice compila:</p>

<span class='rusttest'>macro_rules! foo {
    () =&gt; (fn x() { });
}

fn main() {
    foo!();
    x();
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>foo</span> {
    () <span class='op'>=&gt;</span> (<span class='kw'>fn</span> <span class='ident'>x</span>() { });
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>foo</span><span class='macro'>!</span>();
    <span class='ident'>x</span>();
}</pre>

<h1 id='macro-ricorsive' class='section-header'><a href='#macro-ricorsive'>Macro ricorsive</a></h1>
<p>Un&#39;espansione di macro può comprendere altre invocazioni di macro, comprese
invocazioni proprio della stessa macro che si sta definendo. Queste macro
ricorsive sono utili per elaborare dell&#39;input strutturato ad albero, come
esemplificato da questa (semplicistica) abbreviazione dell&#39;HTML:</p>

<span class='rusttest'>#![allow(unused_must_use)]
macro_rules! write_html {
    ($w:expr, ) =&gt; (());

    ($w:expr, $e:tt) =&gt; (write!($w, &quot;{}&quot;, $e));

    ($w:expr, $tag:ident [ $($inner:tt)* ] $($rest:tt)*) =&gt; {{
        write!($w, &quot;&lt;{}&gt;&quot;, stringify!($tag));
        write_html!($w, $($inner)*);
        write!($w, &quot;&lt;/{}&gt;&quot;, stringify!($tag));
        write_html!($w, $($rest)*);
    }};
}

fn main() {
  // FIXME(#21826)
    use std::fmt::Write;
    let mut out = String::new();

    write_html!(&amp;mut out,
        html[
            head[title[&quot;Guida alle macro&quot;]]
            body[h1[&quot;Le macro sono il meglio!&quot;]]
        ]);

    assert_eq!(out,
        &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Guida alle macro&lt;/title&gt;&lt;/head&gt;\
         &lt;body&gt;&lt;h1&gt;Le macro sono il meglio!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>write_html</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>:<span class='ident'>expr</span>, ) <span class='op'>=&gt;</span> (());

    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>:<span class='ident'>expr</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>tt</span>) <span class='op'>=&gt;</span> (<span class='macro'>write</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>, <span class='string'>&quot;{}&quot;</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>));

    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>:<span class='ident'>expr</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tag</span>:<span class='ident'>ident</span> [ $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>inner</span>:<span class='ident'>tt</span>)<span class='op'>*</span> ] $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>rest</span>:<span class='ident'>tt</span>)<span class='op'>*</span>) <span class='op'>=&gt;</span> {{
        <span class='macro'>write</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>, <span class='string'>&quot;&lt;{}&gt;&quot;</span>, <span class='macro'>stringify</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tag</span>));
        <span class='macro'>write_html</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>inner</span>)<span class='op'>*</span>);
        <span class='macro'>write</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>, <span class='string'>&quot;&lt;/{}&gt;&quot;</span>, <span class='macro'>stringify</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tag</span>));
        <span class='macro'>write_html</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>rest</span>)<span class='op'>*</span>);
    }};
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fmt</span>::<span class='ident'>Write</span>;
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>out</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();

    <span class='macro'>write_html</span><span class='macro'>!</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>out</span>,
        <span class='ident'>html</span>[
            <span class='ident'>head</span>[<span class='ident'>title</span>[<span class='string'>&quot;Guida alle macro&quot;</span>]]
            <span class='ident'>body</span>[<span class='ident'>h1</span>[<span class='string'>&quot;Le macro sono il meglio!&quot;</span>]]
        ]);

    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>out</span>,
        <span class='string'>&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Guida alle macro&lt;/title&gt;&lt;/head&gt;\
         &lt;body&gt;&lt;h1&gt;Le macro sono il meglio!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>);
}</pre>

<h1 id='debug-del-codice-delle-macro' class='section-header'><a href='#debug-del-codice-delle-macro'>Debug del codice delle macro</a></h1>
<p>Per vedere il risultato dell&#39;espansione delle macro, si esegua
<code>rustc --pretty expanded</code>. L&#39;output rappresenta un interno crate, perciò lo
si può anche inoltrare a <code>rustc</code>, che talvolta produrrà dei messaggi d&#39;errore
migliori di quelli della compilazione originale. Si noti che l&#39;output
di <code>--pretty expanded</code> può avere un significato diverso se più variabili
con lo stesso nome (ma diversi contesti sintattici) sono in gioco nello stesso
ambito. In questo caso <code>--pretty expanded,hygiene</code> esporrà i contesti
sintattici.</p>

<p><code>rustc</code> fornisce due estensioni sintattiche che aiutano il debug delle macro.
Per adesso, sono instabili e richiedono dei feature gate.</p>

<ul>
<li><p><code>log_syntax!(...)</code> stamperà i suoi argomenti sullo standard output, in fase
di compilazione, e si espanderà a niente.</p></li>
<li><p><code>trace_macros!(true)</code> abiliterà l&#39;emissione di un messaggio di compilazione
ogni volta che una macro viene espansa. Si usi <code>trace_macros!(false)</code>
nel corso dell&#39;espansione per disattivarla.</p></li>
</ul>

<h1 id='requisiti-sintattici' class='section-header'><a href='#requisiti-sintattici'>Requisiti sintattici</a></h1>
<p>Anche quando il codice Rust contiene macro non espanse, può essere analizzato
dal parser producendo un completo <a href="glossary.html#abstract-syntax-tree">albero sintattico</a>. Questa proprietà
può essere molto utile per gli editor e per altri strumenti che elaborano
il codice. Ha anche alcune conseguenze per la progettazione del sistema
di macro di Rust.</p>

<p>Una conseguenza è che Rust deve determinare, quando analizza un&#39;invocazione
di macro, se la macro si espanderà in</p>

<ul>
<li>nessuno o alcuni elementi,</li>
<li>nessuno o alcuni metodi,</li>
<li>un&#39;espressione,</li>
<li>un&#39;istruzione, oppure</li>
<li>un pattern.</li>
</ul>

<p>Un&#39;invocazione di macro entro un blocco potrebbe espandersi in alcuni elementi,
oppure in un&#39;espressione / istruzione. Rust usa una semplice regola
per risolvere questa ambiguità. Un&#39;invocazione di macro che si espande
in elementi deve essere o</p>

<ul>
<li>delimitata da graffe, per es. <code>foo! { ... }</code>, oppure</li>
<li>terminata da un punto-e-virgola, per es. <code>foo!(...);</code></li>
</ul>

<p>Un&#39;altra conseguenza dell&#39;analisi pre-espansione è che l&#39;invocazione
della macro deve consistere in token Rust validi. Inoltre, le parentesi tonde,
quadre, e graffe devono essere bilanciate internamente a un&#39;invocazione
di macro. Per esempio, <code>foo!([)</code> è proibito. Questo consente a Rust si sapere
dove finisce l&#39;invocazione della macro.</p>

<p>Più formalmente, il corpo dell&#39;invocazione della macro deve essere una sequenza
di ‘alberi di token’. Un albero di token è definito ricorsivamente come o</p>

<ul>
<li>una sequenza di alberi di token circondati da <code>()</code>, <code>[]</code>, o <code>{}</code>, oppure</li>
<li>qualunque altro token singolo.</li>
</ul>

<p>Internamente a un matcher, ogni metavariabile ha uno ‘specificatore
di frammento’, che identifica a quale forma sintattica combacia. Eccoli:</p>

<ul>
<li><code>ident</code>: un identificatore. Per es.: <code>x</code>, o <code>foo</code>.</li>
<li><code>path</code>: un nome qualificato. Per es.: <code>T::SpecialA</code>.</li>
<li><code>expr</code>: un&#39;espressione. Per es.: <code>2 + 2</code>, o <code>if true { 1 } else { 2 }</code>,
o <code>f(42)</code>.</li>
<li><code>ty</code>: un tipo. Per es.: <code>i32</code>, o <code>Vec&lt;(char, String)&gt;</code>, o <code>&amp;T</code>.</li>
<li><code>pat</code>: un pattern. Per es.: <code>Some(t)</code>, o <code>(17, &#39;a&#39;)</code>, o <code>_</code>.</li>
<li><code>stmt</code>: una singola istruzione. Per es.: <code>let x = 3</code>.</li>
<li><code>block</code>: una sequenza di istruzioni delimitata da graffe, che eventualmente
finisce con un&#39;espressione. Per es.: <code>{ log(errore, &quot;ciao&quot;); return 12; }</code>.</li>
<li><code>item</code>: un <a href="../reference.html#items">elemento</a>. Per es.: <code>fn foo() { }</code>, o <code>struct Bar;</code>.</li>
<li><code>meta</code>: un &quot;meta elemento&quot;, come si trova negli attributi. Per es.:
<code>cfg(target_os = &quot;windows&quot;)</code>.</li>
<li><code>tt</code>: un singolo albero di token.</li>
</ul>

<p>Ci sono altre regole che riguardano il token che segue una metavariabile:</p>

<ul>
<li>le variabili di tipo <code>expr</code> e <code>stmt</code> possono essere seguite solamente da uno
dei seguenti token: <code>=&gt; , ;</code></li>
<li>le variabili di tipo <code>ty</code> e <code>path</code> possono essere seguite solamente da uno
di: <code>=&gt; , = | ; : &gt; [ { as where</code></li>
<li>le variabili di tipo <code>pat</code> possono essere seguite solamente da uno di:
<code>=&gt; , = | if in</code></li>
<li>le variabili di alri tipi possono essere seguite da qualunque token.</li>
</ul>

<p>Queste regole forniscono alla sintassi di Rust un po&#39; di flessibilità
di evolvere senza perdere compatibilità con le macro esistenti.</p>

<p>Il sistema delle macro non tratta affatto l&#39;ambiguità sintattica. Per esempio,
la grammatica <code>$($i:ident)* $e:expr</code> non verrà mai accettato dal parser,
perché il parser sarebbe costretto a scegliere fra analizzare <code>$i</code>
e anlizzare <code>$e</code>. Cambiare la sintassi di invocazione per mettere
un token distintivo davanti può correggere il difetto. In questo caso,
si può scrivere <code>$(I $i:ident)* E $e:expr</code>.</p>

<h1 id='gli-ambiti-e-limportexport-di-macro' class='section-header'><a href='#gli-ambiti-e-limportexport-di-macro'>Gli ambiti e l&#39;import/export di macro</a></h1>
<p>Le macro vengono espanse in una fase iniziale della compilazione, prima della
risoluzione dei nomi. Uno svantaggio è che gli ambiti funzionano diversamente
per le macro, rispetto agli altri costrutti del linguaggio.</p>

<p>Sia la definizione che l&#39;espansione delle macro avvengono in un singolo
attraversamento lessicale del codice sorgente del crate. Quindi una macro
definita nell&#39;ambito del modulo è visibile a tutto il codice seguente nello
stesso modulo, che comprende il corpo di ogni successivo elemendo <code>mod</code> figlio.</p>

<p>Una macro definita entro il corpo di un&#39;unica <code>fn</code>, o da qualunque altra parte
non nell&#39;ambito di un modulo, è visibile solamente entro quell&#39;elemento.</p>

<p>Se un modulo ha l&#39;attributo <code>macro_use</code>, le sue macro sono visibili anche nel
suo modulo genitore dopo l&#39;elemento <code>mod</code> del figlio. Se anche il genitore
ha <code>macro_use</code> allora le macro saranno visibili nel nonno dopo l&#39;elemento
<code>mod</code> del genitore, e così via.</p>

<p>L&#39;attributo <code>macro_use</code> può apparire anche su <code>extern crate</code>. In questo
contesto controlla quali macro vengono caricate da crate esterno, per es.:</p>

<span class='rusttest'>fn main() {
    #[macro_use(foo, bar)]
extern crate baz;
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>macro_use</span>(<span class='ident'>foo</span>, <span class='ident'>bar</span>)]</span>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>baz</span>;</pre>

<p>Se l&#39;attributo è dato semplicemente come <code>#[macro_use]</code>, tutte le macro vengono
caricate. Se non c&#39;è nessun attributo <code>#[macro_use]</code> allora nessuna macro viene
caricata. Solamente le macro definite con l&#39;attributo <code>#[macro_export]</code> possono
essere caricate.</p>

<p>Per caricare le macro di un crate senza linkarlo nell&#39;output, si usi anche
l&#39;attributo use <code>#[no_link]</code>.</p>

<p>Per esempio:</p>

<span class='rusttest'>macro_rules! m1 { () =&gt; (()) }

// qui è visibile: m1

mod foo {
    // qui è visibile: m1

    #[macro_export]
    macro_rules! m2 { () =&gt; (()) }

    // qui sono visibili: m1, m2
}

// qui è visibile: m1

macro_rules! m3 { () =&gt; (()) }

// qui sono visibili: m1, m3

#[macro_use]
mod bar {
    // qui sono visibili: m1, m3

    macro_rules! m4 { () =&gt; (()) }

    // qui sono visibili: m1, m3, m4
}

// qui sono visibili: m1, m3, m4
fn main() { }
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>m1</span> { () <span class='op'>=&gt;</span> (()) }

<span class='comment'>// qui è visibile: m1</span>

<span class='kw'>mod</span> <span class='ident'>foo</span> {
    <span class='comment'>// qui è visibile: m1</span>

    <span class='attribute'>#[<span class='ident'>macro_export</span>]</span>
    <span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>m2</span> { () <span class='op'>=&gt;</span> (()) }

    <span class='comment'>// qui sono visibili: m1, m2</span>
}

<span class='comment'>// qui è visibile: m1</span>

<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>m3</span> { () <span class='op'>=&gt;</span> (()) }

<span class='comment'>// qui sono visibili: m1, m3</span>

<span class='attribute'>#[<span class='ident'>macro_use</span>]</span>
<span class='kw'>mod</span> <span class='ident'>bar</span> {
    <span class='comment'>// qui sono visibili: m1, m3</span>

    <span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>m4</span> { () <span class='op'>=&gt;</span> (()) }

    <span class='comment'>// qui sono visibili: m1, m3, m4</span>
}

<span class='comment'>// qui sono visibili: m1, m3, m4</span></pre>

<p>Quando questa libreria viene caricata usando <code>#[macro_use] extern crate</code>,
verrà importata solo <code>m2</code>.</p>

<p>Il Rust Reference ha un <a href="../reference.html#macro-related-attributes">elenco di attributi relativi alle macro</a>.</p>

<h1 id='la-variabile-crate' class='section-header'><a href='#la-variabile-crate'>La variabile <code>$crate</code></a></h1>
<p>Un&#39;ulteriore difficoltà avviene quando una macro viene usata in più crate.
Diciamo che <code>mylib</code> definisce</p>

<span class='rusttest'>pub fn incrementa(x: u32) -&gt; u32 {
    x + 1
}

#[macro_export]
macro_rules! inc_a {
    ($x:expr) =&gt; ( ::incrementa($x) )
}

#[macro_export]
macro_rules! inc_b {
    ($x:expr) =&gt; ( ::mylib::increment($x) )
}
fn main() { }
</span><pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>incrementa</span>(<span class='ident'>x</span>: <span class='ident'>u32</span>) <span class='op'>-&gt;</span> <span class='ident'>u32</span> {
    <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>
}

<span class='attribute'>#[<span class='ident'>macro_export</span>]</span>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>inc_a</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> ( ::<span class='ident'>incrementa</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>) )
}

<span class='attribute'>#[<span class='ident'>macro_export</span>]</span>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>inc_b</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> ( ::<span class='ident'>mylib</span>::<span class='ident'>increment</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>) )
}</pre>

<p><code>inc_a</code> funziona solamente entro <code>mylib</code>, mentre <code>inc_b</code> funziona solamente
al di fuori della libreria. Inoltre, <code>inc_b</code> non funzionerà se l&#39;utente
importerà <code>mylib</code> sotto un altro nome.</p>

<p>Rust non ha (ancora) un sistema d&#39;igiene per i riferimenti dei crate, ma
fornisce una semplice soluzione a questo problema. Entro una macro importata
da un crate chiamato <code>foo</code>, la speciale variabile di macro <code>$crate</code>
si espanderà in <code>::foo</code>. D&#39;altra parte, quando una macro è definita e poi usata
nello stesso crate, <code>$crate</code> si espanderà a niente. Ciò significa
che possiamo scrivere</p>

<span class='rusttest'>#[macro_export]
macro_rules! inc {
    ($x:expr) =&gt; ( $crate::incrementa($x) )
}
fn main() { }
</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>macro_export</span>]</span>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>inc</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> ( <span class='macro-nonterminal'>$</span><span class='kw'>crate</span>::<span class='macro-nonterminal'>incrementa</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>) )
}</pre>

<p>per definire una singola macro che funziona sia all&#39;interno che all&#39;esterno
della nostra libreria. Il nome della funzione si espanderà a <code>::increment</code> in
un caso, e a <code>::mylib::increment</code> nell&#39;altro.</p>

<p>Per mantenere semplice e corretto questo sistema, <code>#[macro_use] extern crate ...</code> può apparire solamente alla radice del nostro crate, non dentro un <code>mod</code>.</p>

<h1 id='lestremità-profonda' class='section-header'><a href='#lestremità-profonda'>L&#39;estremità profonda</a></h1>
<p>La sezione introduttiva ha accennato alle macro ricorsive, ma non ha raccontato
tutta la storia. Le macro ricorsive sono utili per un&#39;altra ragione: ogni
invocazione ricorsiva dà un&#39;altra opportunità di far combaciare gli argomenti
della macro.</p>

<p>Come esempio estremo, è possibile, per quanto poco consigliabile, implementare
l&#39;automa del linguaggio esoterico di programmazione <a href="https://esolangs.org/wiki/Bitwise_Cyclic_Tag">Bitwise_Cyclic_Tag</a> entro il sistema delle macro
di Rust.</p>

<span class='rusttest'>fn main() {
    macro_rules! bct {
    // cmd 0:  d ... =&gt; ...
    (0, $($ps:tt),* ; $_d:tt)
        =&gt; (bct!($($ps),*, 0 ; ));
    (0, $($ps:tt),* ; $_d:tt, $($ds:tt),*)
        =&gt; (bct!($($ps),*, 0 ; $($ds),*));

    // cmd 1p:  1 ... =&gt; 1 ... p
    (1, $p:tt, $($ps:tt),* ; 1)
        =&gt; (bct!($($ps),*, 1, $p ; 1, $p));
    (1, $p:tt, $($ps:tt),* ; 1, $($ds:tt),*)
        =&gt; (bct!($($ps),*, 1, $p ; 1, $($ds),*, $p));

    // cmd 1p:  0 ... =&gt; 0 ...
    (1, $p:tt, $($ps:tt),* ; $($ds:tt),*)
        =&gt; (bct!($($ps),*, 1, $p ; $($ds),*));

    // arrestati quando la stringa di dati è vuota
    ( $($ps:tt),* ; )
        =&gt; (());
}
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>bct</span> {
    <span class='comment'>// cmd 0:  d ... =&gt; ...</span>
    (<span class='number'>0</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>:<span class='ident'>tt</span>),<span class='op'>*</span> ; <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>_d</span>:<span class='ident'>tt</span>)
        <span class='op'>=&gt;</span> (<span class='macro'>bct</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>),<span class='op'>*</span>, <span class='number'>0</span> ; ));
    (<span class='number'>0</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>:<span class='ident'>tt</span>),<span class='op'>*</span> ; <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>_d</span>:<span class='ident'>tt</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ds</span>:<span class='ident'>tt</span>),<span class='op'>*</span>)
        <span class='op'>=&gt;</span> (<span class='macro'>bct</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>),<span class='op'>*</span>, <span class='number'>0</span> ; $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ds</span>),<span class='op'>*</span>));

    <span class='comment'>// cmd 1p:  1 ... =&gt; 1 ... p</span>
    (<span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span>:<span class='ident'>tt</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>:<span class='ident'>tt</span>),<span class='op'>*</span> ; <span class='number'>1</span>)
        <span class='op'>=&gt;</span> (<span class='macro'>bct</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>),<span class='op'>*</span>, <span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span> ; <span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span>));
    (<span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span>:<span class='ident'>tt</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>:<span class='ident'>tt</span>),<span class='op'>*</span> ; <span class='number'>1</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ds</span>:<span class='ident'>tt</span>),<span class='op'>*</span>)
        <span class='op'>=&gt;</span> (<span class='macro'>bct</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>),<span class='op'>*</span>, <span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span> ; <span class='number'>1</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ds</span>),<span class='op'>*</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span>));

    <span class='comment'>// cmd 1p:  0 ... =&gt; 0 ...</span>
    (<span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span>:<span class='ident'>tt</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>:<span class='ident'>tt</span>),<span class='op'>*</span> ; $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ds</span>:<span class='ident'>tt</span>),<span class='op'>*</span>)
        <span class='op'>=&gt;</span> (<span class='macro'>bct</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>),<span class='op'>*</span>, <span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span> ; $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ds</span>),<span class='op'>*</span>));

    <span class='comment'>// arrestati quando la stringa di dati è vuota</span>
    ( $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>:<span class='ident'>tt</span>),<span class='op'>*</span> ; )
        <span class='op'>=&gt;</span> (());
}</pre>

<p>Esercizio: usa delle macro per ridurre la duplicazione nella definizione
della macro <code>bct!</code> scritta qui sopra.</p>

<h1 id='macro-tipiche' class='section-header'><a href='#macro-tipiche'>Macro tipiche</a></h1>
<p>Ecco alcune macro che si incontrano spesso nel codice Rust.</p>

<h2 id='panic' class='section-header'><a href='#panic'>panic!</a></h2>
<p>Questa macro provoca il panico nel thread corrente. Le si può dare un messaggio
da emettere:</p>

<span class='rusttest'>fn main() {
    panic!(&quot;oh no!&quot;);
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;oh no!&quot;</span>);</pre>

<h2 id='vec' class='section-header'><a href='#vec'>vec!</a></h2>
<p>La macro <code>vec!</code> è usata spesso in questo libro. Crea agevolmente dei <code>Vec&lt;T&gt;</code>:</p>

<span class='rusttest'>fn main() {
    let v = vec![1, 2, 3, 4, 5];
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>];</pre>

<p>Consente anche di creare un vettore ripetendo un valore. Per esempio,
per avere un vettore di cento zeri:</p>

<span class='rusttest'>fn main() {
    let v = vec![0; 100];
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>0</span>; <span class='number'>100</span>];</pre>

<h2 id='assert-and-assert_eq' class='section-header'><a href='#assert-and-assert_eq'>assert! and assert_eq!</a></h2>
<p>Queste due macro sono usate nei test. <code>assert!</code> prende un booleano.
<code>assert_eq!</code> prende due valori e verifica che siano uguali. <code>true</code> passa,
<code>false</code> va in <code>panic!</code>. Così:</p>

<span class='rusttest'>fn main() {
    // Ok!

assert!(true);
assert_eq!(5, 3 + 2);

// non va :(

assert!(5 &lt; 3);
assert_eq!(5, 3);
}</span><pre class='rust rust-example-rendered'>
<span class='comment'>// Ok!</span>

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='bool-val'>true</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>5</span>, <span class='number'>3</span> <span class='op'>+</span> <span class='number'>2</span>);

<span class='comment'>// non va :(</span>

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='number'>5</span> <span class='op'>&lt;</span> <span class='number'>3</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>5</span>, <span class='number'>3</span>);</pre>

<h2 id='try' class='section-header'><a href='#try'>try!</a></h2>
<p><code>try!</code> serve alla gestione degli errori. Prende qualcosa che può rendere
un <code>Result&lt;T, E&gt;</code>, e dà il <code>T</code> se il risultato è un <code>Ok&lt;T&gt;</code>, e altrimenti esce
restituendo <code>Err(E)</code>. Così:</p>

<span class='rusttest'>fn main() {
    use std::fs::File;

fn foo() -&gt; std::io::Result&lt;()&gt; {
    let f = try!(File::create(&quot;foo.txt&quot;));

    Ok(())
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>;

<span class='kw'>fn</span> <span class='ident'>foo</span>() <span class='op'>-&gt;</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='prelude-ty'>Result</span><span class='op'>&lt;</span>()<span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>File</span>::<span class='ident'>create</span>(<span class='string'>&quot;foo.txt&quot;</span>));

    <span class='prelude-val'>Ok</span>(())
}</pre>

<p>Questo è l&#39;equivalente, più pulito, di questo:</p>

<span class='rusttest'>fn main() {
    use std::fs::File;

fn foo() -&gt; std::io::Result&lt;()&gt; {
    let f = match File::create(&quot;foo.txt&quot;) {
        Ok(t) =&gt; t,
        Err(e) =&gt; return Err(e),
    };

    Ok(())
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>;

<span class='kw'>fn</span> <span class='ident'>foo</span>() <span class='op'>-&gt;</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='prelude-ty'>Result</span><span class='op'>&lt;</span>()<span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>File</span>::<span class='ident'>create</span>(<span class='string'>&quot;foo.txt&quot;</span>) {
        <span class='prelude-val'>Ok</span>(<span class='ident'>t</span>) <span class='op'>=&gt;</span> <span class='ident'>t</span>,
        <span class='prelude-val'>Err</span>(<span class='ident'>e</span>) <span class='op'>=&gt;</span> <span class='kw'>return</span> <span class='prelude-val'>Err</span>(<span class='ident'>e</span>),
    };

    <span class='prelude-val'>Ok</span>(())
}</pre>

<h2 id='unreachable' class='section-header'><a href='#unreachable'>unreachable!</a></h2>
<p>Questa macro serve quando si ritiene che un punto del codice non dovrebbe mai
essere raggiunto:</p>

<span class='rusttest'>fn main() {
    if false {
    unreachable!();
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>if</span> <span class='bool-val'>false</span> {
    <span class='macro'>unreachable</span><span class='macro'>!</span>();
}</pre>

<p>Talvolta, il compilatore può condurre a una diramazione che si è convintissimi
che non dovrebbe mai essere presa. In questi casi, si usi questa macro, così
che se ci si sbaglia, si otterrà un bel <code>panic!</code>.</p>

<span class='rusttest'>fn main() {
    let x: Option&lt;i32&gt; = None;

match x {
    Some(_) =&gt; unreachable!(),
    None =&gt; println!(&quot;Lo sapevo che x era None!&quot;),
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='prelude-val'>None</span>;

<span class='kw'>match</span> <span class='ident'>x</span> {
    <span class='prelude-val'>Some</span>(_) <span class='op'>=&gt;</span> <span class='macro'>unreachable</span><span class='macro'>!</span>(),
    <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Lo sapevo che x era None!&quot;</span>),
}</pre>

<h2 id='unimplemented' class='section-header'><a href='#unimplemented'>unimplemented!</a></h2>
<p>La macro <code>unimplemented!</code> può servire quando si sta provando a scrivere
una funzione del tipo giusto, ma che non ha ancora un corpo. Un esempio
di questa situazione è quando si implementa un tratto che ha più metodi
da definire, e si vuole affrontarne uno per volta. Si definiscano gli altri
come <code>unimplemented!</code> finché non se ne scrive un corpo corretto.</p>

<h1 id='macro-procedurali' class='section-header'><a href='#macro-procedurali'>Macro procedurali</a></h1>
<p>Se il sistema delle macro di Rust non può fare quello di cui si ha bisogno,
si potrebbe voler scrvere invece un <a href="compiler-plugins.html">plugin per il compilatore</a>. Rispetto alle macro <code>macro_rules!</code>, ciò richiede
sostanzialmente più lavoro, le interfacce sono molto meno stabili,
e i difetti possono essere molto più difficili da risolvere. In cambio
si ottiene la flessibilità  di eseguire del codice Rust arbitrario all&#39;interno
del compilatore. Per questa ragione, i plugin di estensione sintattica
sono talvolta chiamati ‘macro procedurali’.</p>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>L&#39;effettiva definizione di <code>vec!</code> contenuta nella libreria
       collections differisce da quella presentata qui, per ragioni
       sia di efficienza che di riusabilità.&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>