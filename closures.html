<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Chiusure [&quot;closure&quot;]</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduzione</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Come Iniziare</a>
</li>
<li><a  href='guessing-game.html'><b>3.</b> Tutorial: Gioco-indovina</a>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> Sintassi e semantica</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>4.1.</b> Legami di variabili</a>
</li>
<li><a  href='functions.html'><b>4.2.</b> Funzioni</a>
</li>
<li><a  href='primitive-types.html'><b>4.3.</b> Tipi primitivi</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> Commenti</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>4.6.</b> Cicli</a>
</li>
<li><a  href='vectors.html'><b>4.7.</b> Vettori</a>
</li>
<li><a  href='ownership.html'><b>4.8.</b> Possesso</a>
</li>
<li><a  href='references-and-borrowing.html'><b>4.9.</b> Riferimenti e prestito</a>
</li>
<li><a  href='lifetimes.html'><b>4.10.</b> Tempo di vita</a>
</li>
<li><a  href='mutability.html'><b>4.11.</b> Mutabilità</a>
</li>
<li><a  href='structs.html'><b>4.12.</b> Strutture</a>
</li>
<li><a  href='enums.html'><b>4.13.</b> Enumerazioni</a>
</li>
<li><a  href='match.html'><b>4.14.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>4.15.</b> Pattern</a>
</li>
<li><a  href='method-syntax.html'><b>4.16.</b> Sintassi dei metodi</a>
</li>
<li><a  href='strings.html'><b>4.17.</b> Stringhe</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> Genericità</a>
</li>
<li><a  href='traits.html'><b>4.19.</b> Tratti</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> `if let`</a>
</li>
<li><a  href='trait-objects.html'><b>4.22.</b> Oggetti-tratti</a>
</li>
<li><a class='active' href='closures.html'><b>4.23.</b> Chiusure</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> Sintassi universale di chiamata di funzione</a>
</li>
<li><a  href='crates-and-modules.html'><b>4.25.</b> Crate e moduli</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const` e `static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> Attributi</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> Alias tramite `type`</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> Forzatura di tipo</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> Tipi associati</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> Tipi non dimensionati</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> Operatori e sovraccaricamento</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Coercizione Deref</a>
</li>
<li><a  href='macros.html'><b>4.34.</b> Le macro</a>
</li>
<li><a  href='raw-pointers.html'><b>4.35.</b> Puntatori grezzi</a>
</li>
<li><a  href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Rust efficace</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> Lo stack e lo heap</a>
</li>
<li><a  href='testing.html'><b>5.2.</b> Collaudo</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> Compilazione condizionale</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> Documentazione</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> Iteratori</a>
</li>
<li><a  href='concurrency.html'><b>5.6.</b> Concorrenza</a>
</li>
<li><a  href='error-handling.html'><b>5.7.</b> Gestione degli errori</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> Scegliere le garanzie</a>
</li>
<li><a  href='ffi.html'><b>5.9.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> Prestito e AsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> Canali di rilascio</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> Usare Rust senza la libreria standard</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Rust notturno</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Plugin del compilatore</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Assembly in-line</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> Omettere la libreria stdandard</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinseci</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Elementi "lang"</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> Link avanzato</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Collaudi prestazionali</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Sintassi di box e relativi pattern</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Pattern di slice</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Costanti associate</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> Allocatori personalizzati</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> Glossario</a>
</li>
<li><a  href='syntax-index.html'><b>8.</b> Indice analitico della sintassi</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Chiusure [&quot;closure&quot;]</h1>
    <p>Talvolta è utile racchiudere una funzione e le <em>variabili libere</em> per ottenere
maggiore chiarezza e riutilizzo. Le variabili libere che possono essere usate
vengono dall&#39;ambito circostante, e vengono &#39;rinchiuse&#39; quando vengono
usate nella funzione. Da ciò deriva il nome ‘chiusura’, e Rust ne fornisce
un&#39;implementazione davvero ottima, come vedremo.</p>

<h1 id='sintassi' class='section-header'><a href='#sintassi'>Sintassi</a></h1>
<p>Le chiusure si presentano così:</p>

<span class='rusttest'>fn main() {
    let piu_uno = |x: i32| x + 1;

assert_eq!(6, piu_uno(5));
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>piu_uno</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>i32</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>;

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>6</span>, <span class='ident'>piu_uno</span>(<span class='number'>5</span>));</pre>

<p>Abbiamo creato un legame, <code>piu_uno</code>, e l&#39;abbiamo assegnato a una chiusura.
Gli argomenti della chiusura vanno fra due caratteri &#39;pipe&#39; (<code>|</code>);
mentre il corpo della chiusura è un&#39;espressione, in questo caso, <code>x + 1</code>.
Si noti che <code>{ }</code> è un&#39;espressione, e quindi si possono scrivere chiusure
che contengono più istruzioni, in questo modo:</p>

<span class='rusttest'>fn main() {
    let piu_due = |x| {
    let mut risultato: i32 = x;
    risultato += 1;
    risultato += 1;
    risultato
};
assert_eq!(9, piu_due(7));
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>piu_due</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>risultato</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>x</span>;
    <span class='ident'>risultato</span> <span class='op'>+=</span> <span class='number'>1</span>;
    <span class='ident'>risultato</span> <span class='op'>+=</span> <span class='number'>1</span>;
    <span class='ident'>risultato</span>
};
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>9</span>, <span class='ident'>piu_due</span>(<span class='number'>7</span>));</pre>

<p>Si notino alcune cose riguardo le chiusure che sono un po&#39; diverse dalle
normali funzioni con nome definite tramite <code>fn</code>. La prima cosa è che
non abbiamo dovuto annotare i tipi degli argomenti che la chiusura prende
né il valore che restituisce. È consentito:</p>

<span class='rusttest'>fn main() {
    let piu_uno = |x: i32| -&gt; i32 { x + 1 };
assert_eq!(6, piu_uno(5));
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>piu_uno</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>i32</span><span class='op'>|</span> <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span> };
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>6</span>, <span class='ident'>piu_uno</span>(<span class='number'>5</span>));</pre>

<p>ma non è obbligatorio. Perché? Di base, è stato scelto per praticità. Mentre
specificare il tipo completo per le funzioni con nome è di aiuto con cose
come la documentazione e le interfacce dei tipi, le complete firme dei tipi
delle chiusure sono documentate di rado dato che sono anonime, e non
provocano il tipo di errori a distanza che possono essere provocati
dall&#39;inferire i tipi delle funzioni con nome.</p>

<p>La seconda cosa è che la sintassi è simile, ma un po&#39; diversa. Qui sono
stati aggiunti spazi per facilitare il confronto:</p>

<span class='rusttest'>fn main() {
    fn  piu_uno_v1   (x: i32) -&gt; i32 { x + 1 }
let piu_uno_v2 = |x: i32| -&gt; i32 { x + 1 };
let piu_uno_v3 = |x: i32|          x + 1  ;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span>  <span class='ident'>piu_uno_v1</span>   (<span class='ident'>x</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span> }
<span class='kw'>let</span> <span class='ident'>piu_uno_v2</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>i32</span><span class='op'>|</span> <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span> };
<span class='kw'>let</span> <span class='ident'>piu_uno_v3</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>i32</span><span class='op'>|</span>          <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>  ;</pre>

<p>Piccole differenze, ma sono simili.</p>

<h1 id='le-chiusure-e-il-loro-ambiente' class='section-header'><a href='#le-chiusure-e-il-loro-ambiente'>Le chiusure e il loro ambiente</a></h1>
<p>L&#39;ambiente per una chiusura può comprendere i legami del suo ambito
circostante oltre agli argomenti e ai legami locali. Si presenta così:</p>

<span class='rusttest'>fn main() {
    let numero = 5;
let piu_numero = |x: i32| x + numero;
assert_eq!(10, piu_numero(5));
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>numero</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='kw'>let</span> <span class='ident'>piu_numero</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>i32</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>numero</span>;
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>10</span>, <span class='ident'>piu_numero</span>(<span class='number'>5</span>));</pre>

<p>Questa chiusura, <code>piu_numero</code>, fa riferimento a un legame <code>let</code>
nel suo ambito: <code>numero</code>. Più specificamente, prende in prestito il legame.
Se facciamo qualcosa che entrasse in conflitto con quel legame, otterremmo
un errore. Come questo:</p>

<span class='rusttest'>fn main() {
    let mut numero = 5;
let piu_numero = |x: i32| x + numero;
let y = &amp;mut numero;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>numero</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='kw'>let</span> <span class='ident'>piu_numero</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>i32</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>numero</span>;
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>numero</span>;</pre>

<p>Che va in errore con:</p>

<pre><code class="language-text">error: cannot borrow `numero` as mutable because it is also borrowed as immutable
    let y = &amp;mut numero;
                 ^~~~~~
note: previous borrow of `numero` occurs here due to use in closure; the immutable
  borrow prevents subsequent moves or mutable borrows of `numero` until the borrow
  ends
    let piu_numero = |x| x + numero;
                   ^~~~~~~~~~~~~~~~
note: previous borrow ends here
fn main() {
    let mut numero = 5;
    let piu_numero = |x| x + numero;

    let y = &amp;mut numero;
}
^
</code></pre>

<p>Un messaggio d&#39;errore prolisso ma utile! Come dice, non si può prendere <code>num</code>
a prestito mutabile, perché la chiusura lo sta già tenendo a prestito.
Ma se lasciamo uscire di ambito la chiusura, lo possiamo fare:</p>

<span class='rusttest'>fn main() {
    let mut numero = 5;
{
    let piu_numero = |x: i32| x + numero;
} // piu_numero esce di ambito, e quindi il prestito di &#39;numero&#39; finisce

let y = &amp;mut numero;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>numero</span> <span class='op'>=</span> <span class='number'>5</span>;
{
    <span class='kw'>let</span> <span class='ident'>piu_numero</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>i32</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>numero</span>;
} <span class='comment'>// piu_numero esce di ambito, e quindi il prestito di &#39;numero&#39; finisce</span>

<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>numero</span>;</pre>

<p>Però, se la chiusura lo richiede, Rust invece prenderà il possesso del legame
e lo sposterà dall&#39;ambiente. Quindi questo non funziona:</p>

<span class='rusttest'>fn main() {
    let numeri = vec![1, 2, 3];

let prende_numeri = || numeri;

println!(&quot;{:?}&quot;, numeri);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>numeri</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='kw'>let</span> <span class='ident'>prende_numeri</span> <span class='op'>=</span> <span class='op'>||</span> <span class='ident'>numeri</span>;

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='ident'>numeri</span>);</pre>

<p>Otteniamo questo errore:</p>

<pre><code class="language-text">note: `numeri` moved into closure environment here because it has type
  `[closure(()) -&gt; collections::vec::Vec&lt;i32&gt;]`, which is non-copyable
let prende_numeri = || numeri;
                    ^~~~~~~~~
</code></pre>

<p><code>Vec&lt;T&gt;</code> ha il possesso del suo contenuto, e quindi, quando
facciamo riferimento ad esso nella nostra chiusura, dobbiamo prendere
possesso di <code>numeri</code>. È lo stesso come se avessimo passato <code>numeri</code>
a una funzione che ne prendesse il possesso.</p>

<h2 id='le-chiusure-move' class='section-header'><a href='#le-chiusure-move'>Le chiusure <code>move</code></a></h2>
<p>Possiamo costringere la nostra chiusura a prendere possesso del suo ambiente
con la parola-chiave <code>move</code>:</p>

<span class='rusttest'>fn main() {
    let numero = 5;

let possiede_numero = move |x: i32| x + numero;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>numero</span> <span class='op'>=</span> <span class='number'>5</span>;

<span class='kw'>let</span> <span class='ident'>possiede_numero</span> <span class='op'>=</span> <span class='kw'>move</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>i32</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>numero</span>;</pre>

<p>Adesso, anche se la parola-chiave è <code>move</code>, le variabili seguono
la normale semantica di spostamento. In questo caso, <code>5</code> implementa <code>Copy</code>,
e così <code>possiede_numero</code> prende possesso di una copia di <code>numero</code>.
E allora che differenza c&#39;è?</p>

<span class='rusttest'>fn main() {
    let mut numero = 5;

{
    let mut aggiungi_numero = |x: i32| numero += x;

    aggiungi_numero(5);
}

assert_eq!(10, numero);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>numero</span> <span class='op'>=</span> <span class='number'>5</span>;

{
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>aggiungi_numero</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>i32</span><span class='op'>|</span> <span class='ident'>numero</span> <span class='op'>+=</span> <span class='ident'>x</span>;

    <span class='ident'>aggiungi_numero</span>(<span class='number'>5</span>);
}

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>10</span>, <span class='ident'>numero</span>);</pre>

<p>Quindi in questo caso, la nostra chiusura ha preso un riferimento mutabile
a <code>numero</code>, e poi, quando abbiamo chiamato <code>aggiungi_numero</code>, ha mutato
il valore soggiacente, come ci aspettavamo. Abbiamo anche dovuto dichiarare
<code>aggiungi_numero</code> come <code>mut</code>, perché stiamo mutando il suo ambiente.</p>

<p>Se lo trasformiamo in una chiusura <code>move</code>, sarà diverso:</p>

<span class='rusttest'>fn main() {
    let mut numero = 5;

{
    let mut aggiungi_numero = move |x: i32| numero += x;

    aggiungi_numero(5);
}

assert_eq!(5, numero);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>numero</span> <span class='op'>=</span> <span class='number'>5</span>;

{
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>aggiungi_numero</span> <span class='op'>=</span> <span class='kw'>move</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>i32</span><span class='op'>|</span> <span class='ident'>numero</span> <span class='op'>+=</span> <span class='ident'>x</span>;

    <span class='ident'>aggiungi_numero</span>(<span class='number'>5</span>);
}

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>5</span>, <span class='ident'>numero</span>);</pre>

<p>Otteneniamo solamente <code>5</code>. Invece di prendere un prestito mutabile sul
nostro <code>numero</code>, abbiamo preso possesso di una sua copia.</p>

<p>Un altro modo di pensare alle chiusure <code>move</code>: danno a una chiusura
il suo stesso frame di stack. Senza <code>move</code>, una chiusura può essere
vincolata al frame di stack che l&#39;ha creata, mentre una chiusura <code>move</code>
è autocontenuta. Ciò comporta, per esempio, che in generale una funzione
non può restituire una chiusura non-<code>move</code>.</p>

<p>Ma prima di parlare di come prendere e restituire chiusure, dovremmo
parlare ancora un po&#39; del modo in cui le chiusure sono implementate.
Essendo un linguaggio di sistemi, Rust dà moltissimo controllo su ciò che fa
il codice, e le chiusure non sono da meno.</p>

<h1 id='implementazione-delle-chiusure' class='section-header'><a href='#implementazione-delle-chiusure'>Implementazione delle chiusure</a></h1>
<p>L&#39;implementazione delle chiusure di Rust è un po&#39; diversa dagli altri
linguaggi. Effettivamente sono un addolcimento sintattico dei tratti.
Prima di leggere questa sezione, ci si assicuri di aver letto la sezione
sui <a href="traits.html">tratti</a>, e anche quella sugli <a href="trait-objects.html">oggetti-tratto</a>.</p>

<p>Capito tutto? Bene.</p>

<p>La chiave per capire come funzionano sotto il cofano le chiusure è qualcosa
di un po&#39; strano: Usare <code>()</code> per chiamare una funzione, come in <code>foo()</code>,
è un operatore sovraccaricabile. Da questo, tutto il resto scatta
al suo posto. In Rust, si usa il sistema dei tratti per sovraccaricare
gli operatori. Chiamare funzioni non è diverso. Ci sono tre tratti distinti
da sovraccaricare:</p>

<span class='rusttest'>fn main() {
    mod foo {
pub trait Fn&lt;Args&gt; : FnMut&lt;Args&gt; {
    extern &quot;rust-call&quot; fn call(&amp;self, args: Args) -&gt; Self::Output;
}

pub trait FnMut&lt;Args&gt; : FnOnce&lt;Args&gt; {
    extern &quot;rust-call&quot; fn call_mut(&amp;mut self, args: Args) -&gt; Self::Output;
}

pub trait FnOnce&lt;Args&gt; {
    type Output;

    extern &quot;rust-call&quot; fn call_once(self, args: Args) -&gt; Self::Output;
}
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>Fn</span><span class='op'>&lt;</span><span class='ident'>Args</span><span class='op'>&gt;</span> : <span class='ident'>FnMut</span><span class='op'>&lt;</span><span class='ident'>Args</span><span class='op'>&gt;</span> {
    <span class='kw'>extern</span> <span class='string'>&quot;rust-call&quot;</span> <span class='kw'>fn</span> <span class='ident'>call</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>args</span>: <span class='ident'>Args</span>) <span class='op'>-&gt;</span> <span class='self'>Self</span>::<span class='ident'>Output</span>;
}

<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>FnMut</span><span class='op'>&lt;</span><span class='ident'>Args</span><span class='op'>&gt;</span> : <span class='ident'>FnOnce</span><span class='op'>&lt;</span><span class='ident'>Args</span><span class='op'>&gt;</span> {
    <span class='kw'>extern</span> <span class='string'>&quot;rust-call&quot;</span> <span class='kw'>fn</span> <span class='ident'>call_mut</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>args</span>: <span class='ident'>Args</span>) <span class='op'>-&gt;</span> <span class='self'>Self</span>::<span class='ident'>Output</span>;
}

<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>FnOnce</span><span class='op'>&lt;</span><span class='ident'>Args</span><span class='op'>&gt;</span> {
    <span class='kw'>type</span> <span class='ident'>Output</span>;

    <span class='kw'>extern</span> <span class='string'>&quot;rust-call&quot;</span> <span class='kw'>fn</span> <span class='ident'>call_once</span>(<span class='self'>self</span>, <span class='ident'>args</span>: <span class='ident'>Args</span>) <span class='op'>-&gt;</span> <span class='self'>Self</span>::<span class='ident'>Output</span>;
}</pre>

<p>Si noteranno alcune differenze fra questi tratti, ma una grossa è <code>self</code>:
<code>Fn</code> prende <code>&amp;self</code>, <code>FnMut</code> prende <code>&amp;mut self</code>, e <code>FnOnce</code> prende <code>self</code>.
Ciò considera tutte e tre i generi di <code>self</code> permessi dalla solita sintassi
di chiamata di metodo. Ma li abbiamo separati in tre tratti, invece
di averne uno solo. Questo ci consente di controllare con precisione
quali generi di chiusure possiamo prendere.</p>

<p>La sintassi <code>|| {}</code> per le chiusure è un addolcimento per questi tre tratti.
Rust genererà una struct che rappresenta l&#39;ambiente, implementerà il tratto
appropriato per essa, e poi lo userà.</p>

<h1 id='prendere-chiusure-come-argomenti' class='section-header'><a href='#prendere-chiusure-come-argomenti'>Prendere chiusure come argomenti</a></h1>
<p>Adesso che sappiamo che le chiusure sono tratti, sappiamo già come accettare
e restituire le chiusure: proprio come ogni altro tratto!</p>

<p>Ciò comporta anche che possiamo scegliere tra il dispatch statico e
quello dinamico. Prima, scriviamo una funzione che prende qualcosa
di chiamabile, lo chiamiamo, e restituiamo il risultato:</p>

<span class='rusttest'>fn main() {
    fn chiama_con_uno&lt;F&gt;(una_chiusura: F) -&gt; i32
    where F : Fn(i32) -&gt; i32 {
    una_chiusura(1)
}

let risposta = chiama_con_uno(|x| x + 2);

assert_eq!(3, risposta);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>chiama_con_uno</span><span class='op'>&lt;</span><span class='ident'>F</span><span class='op'>&gt;</span>(<span class='ident'>una_chiusura</span>: <span class='ident'>F</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span>
    <span class='kw'>where</span> <span class='ident'>F</span> : <span class='ident'>Fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='ident'>una_chiusura</span>(<span class='number'>1</span>)
}

<span class='kw'>let</span> <span class='ident'>risposta</span> <span class='op'>=</span> <span class='ident'>chiama_con_uno</span>(<span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>2</span>);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>3</span>, <span class='ident'>risposta</span>);</pre>

<p>Passiamo la nostra chiusura, <code>|x| x + 2</code>, a <code>chiama_con_uno</code>, che fa quello
che dice il suo nome: chiama la chiusura, dandole <code>1</code> come argomento.</p>

<p>Esaminiamo la firma di <code>chiama_con_uno</code> più in profondità:</p>

<span class='rusttest'>fn main() {
    fn chiama_con_uno&lt;F&gt;(una_chiusura: F) -&gt; i32
   where F : Fn(i32) -&gt; i32 {
   una_chiusura(1) }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>chiama_con_uno</span><span class='op'>&lt;</span><span class='ident'>F</span><span class='op'>&gt;</span>(<span class='ident'>una_chiusura</span>: <span class='ident'>F</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span></pre>

<p>Prendiamo un argomente, che è di tipo <code>F</code>. Inoltre restituiamo un <code>i32</code>.
Questa parte non è interessante. La prossima parte è:</p>

<span class='rusttest'>fn main() {
    fn chiama_con_uno&lt;F&gt;(una_chiusura: F) -&gt; i32
    where F : Fn(i32) -&gt; i32 {
  una_chiusura(1) }
}</span><pre class='rust rust-example-rendered'>
    <span class='kw'>where</span> <span class='ident'>F</span> : <span class='ident'>Fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {</pre>

<p>Siccome <code>Fn</code> è un tratto, possiamo vincolare ad esso il nostro generico.
In questo caso, la nostra chiusura prende un <code>i32</code> come argomento
e restituisce un <code>i32</code>, e quindi il vincolo generico che usiamo
è <code>Fn(i32) -&gt; i32</code>.</p>

<p>Qui c&#39;è un altro punto chiave: siccome stiamo vincolando un generico
con un tratto, questo diventerà monomorfizzato, e perciò, nella chiusura
faremo un dispatch statico. È piuttosto pulito. In molti linguaggi,
le chiusure sono inerentemente allocate su heap, e comporteranno sempre
un dispatch dinamico. In Rust, possiamo allocare su stack l&#39;ambiente
della nostra chiusura, e il eseguire un dispatch statico della chiamata.
Ciò accade davvero spesso con gli iteratori e i loro adattatori,
che spesso prendono come argomenti delle chiusure.</p>

<p>Naturalmente, se vogliamo un dispatch dinamico, possiamo averlo.
Un oggetto-tratto gestisce questo caso, come al solito:</p>

<span class='rusttest'>fn main() {
    fn chiama_con_uno(una_chiusura: &amp;Fn(i32) -&gt; i32) -&gt; i32 {
    una_chiusura(1)
}

let risposta = chiama_con_uno(&amp;|x| x + 2);

assert_eq!(3, risposta);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>chiama_con_uno</span>(<span class='ident'>una_chiusura</span>: <span class='kw-2'>&amp;</span><span class='ident'>Fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='ident'>una_chiusura</span>(<span class='number'>1</span>)
}

<span class='kw'>let</span> <span class='ident'>risposta</span> <span class='op'>=</span> <span class='ident'>chiama_con_uno</span>(<span class='kw-2'>&amp;</span><span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>2</span>);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>3</span>, <span class='ident'>risposta</span>);</pre>

<p>Adesso prendiamo un oggetto-tratto, un <code>&amp;Fn</code>. E dobbiamo creare
un riferimento alla nostra chiusura, quando la passiamo a <code>chiama_con_uno</code>,
e quindi usiamo <code>&amp;||</code>.</p>

<p>Una nota veloce sulle chiusure che usano tempi di vita espliciti.
Talvolta si potrebbe avere una chiusura che prende un riferimento così:</p>

<span class='rusttest'>fn main() {
    fn chiama_con_riferimento&lt;F&gt;(una_chiusura:F) -&gt; i32
    where F: Fn(&amp;i32) -&gt; i32 {

    let mut value = 0;
    una_chiusura(&amp;value)
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>chiama_con_riferimento</span><span class='op'>&lt;</span><span class='ident'>F</span><span class='op'>&gt;</span>(<span class='ident'>una_chiusura</span>:<span class='ident'>F</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span>
    <span class='kw'>where</span> <span class='ident'>F</span>: <span class='ident'>Fn</span>(<span class='kw-2'>&amp;</span><span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {

    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>value</span> <span class='op'>=</span> <span class='number'>0</span>;
    <span class='ident'>una_chiusura</span>(<span class='kw-2'>&amp;</span><span class='ident'>value</span>)
}</pre>

<p>Normalmente si può specificare il tempo di vita dell&#39;argomento alla chiusura.
Potremmo annotarlo nella dichiarazione della funzione:</p>

<span class='rusttest'>fn main() {
    fn chiama_con_riferimento&lt;&#39;a, F&gt;(una_chiusura:F) -&gt; i32
    where F: Fn(&amp;&#39;a i32) -&gt; i32 {
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>chiama_con_riferimento</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>F</span><span class='op'>&gt;</span>(<span class='ident'>una_chiusura</span>:<span class='ident'>F</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span>
    <span class='kw'>where</span> <span class='ident'>F</span>: <span class='ident'>Fn</span>(<span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {</pre>

<p>Però ciò presenta un problema nel nostro caso. Quando si specifica
il tempo di vita esplicito in una funzione, questo lega quel tempo di vita
all&#39;*intero* ambito della funzione invece che appena all&#39;ambito
di invocazione della nostra chiusura. Ciò comporta che il verificatore
dei prestiti vedrà un riferimento mutabile nel medesimo tempo di vita
del nostro riferimento immutabile, non potrà compilarlo.</p>

<p>Per poter dire che ci serve solamente che il tempo di vita sia valido per
l&#39;ambito di invocazione della chiusura, possiamo usare i vincoli dei tratti
di rango superiore (&quot;Higher-Ranked Trait Bounds&quot;) con la sintassi <code>for&lt;...&gt;</code>:</p>

<span class='rusttest'>fn main() {
    fn chiama_con_riferimento&lt;F&gt;(una_chiusura:F) -&gt; i32
    where F: for&lt;&#39;a&gt; Fn(&amp;&#39;a i32) -&gt; i32 {
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>chiama_con_riferimento</span><span class='op'>&lt;</span><span class='ident'>F</span><span class='op'>&gt;</span>(<span class='ident'>una_chiusura</span>:<span class='ident'>F</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span>
    <span class='kw'>where</span> <span class='ident'>F</span>: <span class='kw'>for</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> <span class='ident'>Fn</span>(<span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {</pre>

<p>Ciò consente al compilatore Rust di trovare il tempo di vita minimo
per invocare la nostra chiusura, e soddisfare le regole del verificatore
dei prestiti. Quindi la nostra funzione potrà essere compilata ed eseguita
come ci aspettiamo.</p>

<span class='rusttest'>fn main() {
    fn chiama_con_riferimento&lt;F&gt;(una_chiusura:F) -&gt; i32
    where F: for&lt;&#39;a&gt; Fn(&amp;&#39;a i32) -&gt; i32 {

    let mut value = 0;
    una_chiusura(&amp;value)
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>chiama_con_riferimento</span><span class='op'>&lt;</span><span class='ident'>F</span><span class='op'>&gt;</span>(<span class='ident'>una_chiusura</span>:<span class='ident'>F</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span>
    <span class='kw'>where</span> <span class='ident'>F</span>: <span class='kw'>for</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> <span class='ident'>Fn</span>(<span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {

    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>value</span> <span class='op'>=</span> <span class='number'>0</span>;
    <span class='ident'>una_chiusura</span>(<span class='kw-2'>&amp;</span><span class='ident'>value</span>)
}</pre>

<h1 id='puntatori-a-funzione-e-chiusure' class='section-header'><a href='#puntatori-a-funzione-e-chiusure'>Puntatori a funzione e chiusure</a></h1>
<p>Un puntatore a funzione è un po&#39; come una chiusura che non ha nessun ambiente.
Come tale, si può passare un puntatore a funzione a qualunque funzione
che si aspetta come argomento una chiusura, e funzionerà:</p>

<span class='rusttest'>fn main() {
    fn chiama_con_uno(una_chiusura: &amp;Fn(i32) -&gt; i32) -&gt; i32 {
    una_chiusura(1)
}

fn aggiungi_uno(i: i32) -&gt; i32 {
    i + 1
}

let f = aggiungi_uno;

let risposta = chiama_con_uno(&amp;f);

assert_eq!(2, risposta);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>chiama_con_uno</span>(<span class='ident'>una_chiusura</span>: <span class='kw-2'>&amp;</span><span class='ident'>Fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='ident'>una_chiusura</span>(<span class='number'>1</span>)
}

<span class='kw'>fn</span> <span class='ident'>aggiungi_uno</span>(<span class='ident'>i</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='ident'>i</span> <span class='op'>+</span> <span class='number'>1</span>
}

<span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>aggiungi_uno</span>;

<span class='kw'>let</span> <span class='ident'>risposta</span> <span class='op'>=</span> <span class='ident'>chiama_con_uno</span>(<span class='kw-2'>&amp;</span><span class='ident'>f</span>);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>2</span>, <span class='ident'>risposta</span>);</pre>

<p>In questo esempio, non abbiamo strettamente bisogno della variabile
intermedia <code>f</code>; il nome della funzione va altrettanto bene:</p>

<span class='rusttest'>fn main() {
    let risposta = chiama_con_uno(&amp;aggiungi_uno);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>risposta</span> <span class='op'>=</span> <span class='ident'>chiama_con_uno</span>(<span class='kw-2'>&amp;</span><span class='ident'>aggiungi_uno</span>);</pre>

<h1 id='restituire-chiusure' class='section-header'><a href='#restituire-chiusure'>Restituire chiusure</a></h1>
<p>È molto tipico per il codice in stile funzionale restituire delle chiusure
in varie situazioni. Se si prova a restituire una chiusura, ci si può
imbattere in un errore. Dapprima, può sembrare strano, ma vedremo perché.
Ecco un tentativo plausibile di restituire una chiusura da una funzione:</p>

<span class='rusttest'>fn main() {
    fn factory() -&gt; (Fn(i32) -&gt; i32) {
    let num = 5;

    |x| x + num
}

let f = factory();

let risposta = f(1);
assert_eq!(6, risposta);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>factory</span>() <span class='op'>-&gt;</span> (<span class='ident'>Fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span>) {
    <span class='kw'>let</span> <span class='ident'>num</span> <span class='op'>=</span> <span class='number'>5</span>;

    <span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>num</span>
}

<span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>factory</span>();

<span class='kw'>let</span> <span class='ident'>risposta</span> <span class='op'>=</span> <span class='ident'>f</span>(<span class='number'>1</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>6</span>, <span class='ident'>risposta</span>);</pre>

<p>Questo ci dà questi lunghi errori correlati:</p>

<pre><code class="language-text">error: the trait bound `core::ops::Fn(i32) -&gt; i32 : core::marker::Sized` is not satisfied [E0277]
fn factory() -&gt; (Fn(i32) -&gt; i32) {
                ^~~~~~~~~~~~~~~~
note: `core::ops::Fn(i32) -&gt; i32` does not have a constant size known at compile-time
fn factory() -&gt; (Fn(i32) -&gt; i32) {
                ^~~~~~~~~~~~~~~~
error: the trait bound `core::ops::Fn(i32) -&gt; i32 : core::marker::Sized` is not satisfied [E0277]
let f = factory();
    ^
note: `core::ops::Fn(i32) -&gt; i32` does not have a constant size known at compile-time
let f = factory();
    ^
</code></pre>

<p>Per poter restituire qualcosa da una funzione, Rust deve conoscere
la dimensione del tipo del valore restituito. Ma siccome <code>Fn</code> è un tratto,
potrebbe essere varie cose di varie dimensioni: molti tipi diversi possono
implementare <code>Fn</code>. Un modo facile per dare una dimensione a qualcosa è
prendere un riferimento ad esso, dato che i riferimenti hanno
una dimensione nota. Quindi scriveremmo questo:</p>

<span class='rusttest'>fn main() {
    fn factory() -&gt; &amp;(Fn(i32) -&gt; i32) {
    let num = 5;

    |x| x + num
}

let f = factory();

let risposta = f(1);
assert_eq!(6, risposta);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>factory</span>() <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span>(<span class='ident'>Fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span>) {
    <span class='kw'>let</span> <span class='ident'>num</span> <span class='op'>=</span> <span class='number'>5</span>;

    <span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>num</span>
}

<span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>factory</span>();

<span class='kw'>let</span> <span class='ident'>risposta</span> <span class='op'>=</span> <span class='ident'>f</span>(<span class='number'>1</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>6</span>, <span class='ident'>risposta</span>);</pre>

<p>Ma otteniamo un altro errore:</p>

<pre><code class="language-text">error: missing lifetime specifier [E0106]
fn factory() -&gt; &amp;(Fn(i32) -&gt; i32) {
                ^~~~~~~~~~~~~~~~~
</code></pre>

<p>Giusto. Siccome abbiamo un riferimento, dobbiamo dargli un tempo di vita.
Ma la nostra funzione <code>factory()</code> non prende argomenti, e quindi qui
l&#39;<a href="lifetimes.html#lifetime-elision">elisione</a> non entra in gioco.
Allora che scelte abbiamo? Possiamo provare <code>&#39;static</code>:</p>

<span class='rusttest'>fn main() {
    fn factory() -&gt; &amp;&#39;static (Fn(i32) -&gt; i32) {
    let num = 5;

    |x| x + num
}

let f = factory();

let risposta = f(1);
assert_eq!(6, risposta);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>factory</span>() <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> (<span class='ident'>Fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span>) {
    <span class='kw'>let</span> <span class='ident'>num</span> <span class='op'>=</span> <span class='number'>5</span>;

    <span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>num</span>
}

<span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>factory</span>();

<span class='kw'>let</span> <span class='ident'>risposta</span> <span class='op'>=</span> <span class='ident'>f</span>(<span class='number'>1</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>6</span>, <span class='ident'>risposta</span>);</pre>

<p>Ma otteniamo un altro errore:</p>

<pre><code class="language-text">error: mismatched types:
 expected `&amp;&#39;static core::ops::Fn(i32) -&gt; i32`,
    found `[closure@&lt;anon&gt;:7:9: 7:20]`
(expected &amp;-ptr,
    found closure) [E0308]
         |x| x + num
         ^~~~~~~~~~~

</code></pre>

<p>Questo errore ci fa sapere che non abbiamo una <code>&amp;&#39;static Fn(i32) -&gt; i32</code>,
abbiamo una <code>[closure@&lt;anon&gt;:7:9: 7:20]</code>. Un attimo, cos&#39;è?</p>

<p>Siccome ogni chiusura genera la sua <code>struct</code> ambiente e
la sua implementazione di <code>Fn</code> e compagni, questi tipo sono anonimi.
Esistono solamente per questa chiusura. Quindi Rust li mostra come
<code>closure@&lt;anon&gt;</code>, invece di mostrare un nome autogenerato.</p>

<p>L&#39;errore fa notare anche che come tipo del valore restituito ci si
aspetta un riferimento, ma quello che stiamo provando a restituire non lo è.
Inoltre, non possiamo assegnare direttamente un tempo di vita <code>&#39;static</code>
a un oggetto. Quindi sceglieremo un approccio diverso e restituiremo
un oggetto-tratto incapsulando la <code>Fn</code> in un <code>Box</code>. Questo <em>quasi</em> funziona:</p>

<span class='rusttest'>fn factory() -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {
    let num = 5;

    Box::new(|x| x + num)
}
fn main() {
let f = factory();

let risposta = f(1);
assert_eq!(6, risposta);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>factory</span>() <span class='op'>-&gt;</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span><span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='ident'>num</span> <span class='op'>=</span> <span class='number'>5</span>;

    <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>num</span>)
}
<span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>factory</span>();

<span class='kw'>let</span> <span class='ident'>risposta</span> <span class='op'>=</span> <span class='ident'>f</span>(<span class='number'>1</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>6</span>, <span class='ident'>risposta</span>);</pre>

<p>C&#39;è appena un ultimo difetto:</p>

<pre><code class="language-text">error: closure may outlive the current function, but it borrows `num`,
which is owned by the current function [E0373]
Box::new(|x| x + num)
         ^~~~~~~~~~~
</code></pre>

<p>Beh, come abbiamo discusso prima, le chiusure prendono in prestito
il loro ambiente. E in questo caso, il nostro ambiente è basato su un <code>5</code>
allocato sullo stack, il legame di variabile <code>num</code>. Quindi il prestito
ha il tempo di vita del frame di stack. Perciò se restituissimo
questa chiusura, la chiamata di funzione finirebbe, il frame di stack
andrebbe via, e la nostra chiusura avrebbe catturato un ambiente di memoria
spazzatura! Con un&#39;ultima correzione, lo possiamo far funzionare:</p>

<span class='rusttest'>fn factory() -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {
    let num = 5;

    Box::new(move |x| x + num)
}
fn main() {
let f = factory();

let risposta = f(1);
assert_eq!(6, risposta);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>factory</span>() <span class='op'>-&gt;</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span><span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='ident'>num</span> <span class='op'>=</span> <span class='number'>5</span>;

    <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='kw'>move</span> <span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>num</span>)
}
<span class='kw'>fn</span> <span class='ident'>main</span>() {
<span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>factory</span>();

<span class='kw'>let</span> <span class='ident'>risposta</span> <span class='op'>=</span> <span class='ident'>f</span>(<span class='number'>1</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>6</span>, <span class='ident'>risposta</span>);
}</pre>

<p>Rendendo la chiusura interna un <code>move Fn</code>, creiamo un nuovo frame di stack
per la nostra chiusura. Incapsulandolo in un <code>Box</code>, gli abbiamo dato
una dimensione nota, consentendogli di fuggire dal nostro frame di stack.</p>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>