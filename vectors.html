<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Vettori</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduzione</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Come Iniziare</a>
</li>
<li><a  href='guessing-game.html'><b>3.</b> Tutorial: Gioco-indovina</a>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> Sintassi e semantica</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>4.1.</b> Legami di variabili</a>
</li>
<li><a  href='functions.html'><b>4.2.</b> Funzioni</a>
</li>
<li><a  href='primitive-types.html'><b>4.3.</b> Tipi primitivi</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> Commenti</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>4.6.</b> Cicli</a>
</li>
<li><a class='active' href='vectors.html'><b>4.7.</b> Vettori</a>
</li>
<li><a  href='ownership.html'><b>4.8.</b> Possesso</a>
</li>
<li><a  href='references-and-borrowing.html'><b>4.9.</b> Riferimenti e prestito</a>
</li>
<li><a  href='lifetimes.html'><b>4.10.</b> Tempo di vita</a>
</li>
<li><a  href='mutability.html'><b>4.11.</b> Mutabilità</a>
</li>
<li><a  href='structs.html'><b>4.12.</b> Strutture</a>
</li>
<li><a  href='enums.html'><b>4.13.</b> Enumerazioni</a>
</li>
<li><a  href='match.html'><b>4.14.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>4.15.</b> Pattern</a>
</li>
<li><a  href='method-syntax.html'><b>4.16.</b> Sintassi dei metodi</a>
</li>
<li><a  href='strings.html'><b>4.17.</b> Stringhe</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> Genericità</a>
</li>
<li><a  href='traits.html'><b>4.19.</b> Tratti</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> `if let`</a>
</li>
<li><a  href='trait-objects.html'><b>4.22.</b> Oggetti-tratti</a>
</li>
<li><a  href='closures.html'><b>4.23.</b> Chiusure</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> Sintassi universale di chiamata di funzione</a>
</li>
<li><a  href='crates-and-modules.html'><b>4.25.</b> Crate e moduli</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const` e `static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> Attributi</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> Alias tramite `type`</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> Forzatura di tipo</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> Tipi associati</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> Tipi non dimensionati</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> Operatori e sovraccaricamento</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Coercizione Deref</a>
</li>
<li><a  href='macros.html'><b>4.34.</b> Le macro</a>
</li>
<li><a  href='raw-pointers.html'><b>4.35.</b> Puntatori grezzi</a>
</li>
<li><a  href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Rust efficace</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> Lo stack e lo heap</a>
</li>
<li><a  href='testing.html'><b>5.2.</b> Collaudo</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> Compilazione condizionale</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> Documentazione</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> Iteratori</a>
</li>
<li><a  href='concurrency.html'><b>5.6.</b> Concorrenza</a>
</li>
<li><a  href='error-handling.html'><b>5.7.</b> Gestione degli errori</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> Scegliere le garanzie</a>
</li>
<li><a  href='ffi.html'><b>5.9.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> Prestito e AsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> Canali di rilascio</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> Usare Rust senza la libreria standard</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Rust notturno</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Plugin del compilatore</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Assembly in-line</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> Omettere la libreria stdandard</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinseci</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Elementi "lang"</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> Link avanzato</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Collaudi prestazionali</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Sintassi di box e relativi pattern</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Pattern di slice</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Costanti associate</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> Allocatori personalizzati</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> Glossario</a>
</li>
<li><a  href='syntax-index.html'><b>8.</b> Indice analitico della sintassi</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Vettori</h1>
    <p>Un ‘vettore’ è un array dinamico ossia ‘estendibile’, implementato dal tipo
<a href="../std/vec/index.html"><code>Vec&lt;T&gt;</code></a> nella libreria standard. Il <code>T</code> significa che si possono avere
vettori di ogni tipo (si veda il capitolo su [generici][generic] per avere
maggiori informazioni).
I vettori allocano sempre i loro dati nello heap.
Possono essere creati con la macro <code>vec!</code>:</p>

<span class='rusttest'>fn main() {
    let v = vec![1, 2, 3, 4, 5]; // v: Vec&lt;i32&gt;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>]; <span class='comment'>// v: Vec&lt;i32&gt;</span></pre>

<p>(Si noti che diversamente dalla macro <code>println!</code> che abbiamo usato in passato,
con la macro <code>vec!</code> usiamo le parentesi quadre <code>[]</code>. Rust permette di usare
entrambi i tipi di parentesi in entrambe le situazioni, questo uso è solo
una convenzione.)</p>

<p>C&#39;è una forma alternativa di <code>vec!</code> per ripetere un valore iniziale:</p>

<span class='rusttest'>fn main() {
    let v = vec![0; 10]; // dieci zeri
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>0</span>; <span class='number'>10</span>]; <span class='comment'>// dieci zeri</span></pre>

<p>I vettori immagazzinano il loro contenuto sullo heap come array contigui
di <code>T</code>. Ciò significa che devono essere capaci di sapere la dimensione di <code>T</code>
in fase di compilazione (cioè, quanti byte servono per memorizzare un <code>T</code>?).
La dimensione di alcuni oggetti non si può sapere in fase di compilazione.
Per tali oggetti si dovrà immagazzinare un puntatore a quell&#39;oggetto:
fortunatamente, il tipo <a href="../std/boxed/index.html"><code>Box</code></a> funziona perfettamente a questo scopo.</p>

<h2 id='accedere-agli-elementi' class='section-header'><a href='#accedere-agli-elementi'>Accedere agli elementi</a></h2>
<p>Per ottenere il valore a un particolare indice nel vettore, si usano le <code>[]</code>:</p>

<span class='rusttest'>fn main() {
    let v = vec![1, 2, 3, 4, 5];

println!(&quot;Il terzo elemento di v è {}&quot;, v[2]);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>];

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Il terzo elemento di v è {}&quot;</span>, <span class='ident'>v</span>[<span class='number'>2</span>]);</pre>

<p>Gli indici contano da <code>0</code>, e perciò il terzo elemento è <code>v[2]</code>.</p>

<p>È anche importante notare che si deve indicizzare con il tipo <code>usize</code>:</p>

<span class='rusttest'>fn main() {
    let v = vec![1, 2, 3, 4, 5];

let i: usize = 0;
let j: i32 = 0;

// funziona
v[i];

// non funziona
v[j];
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>];

<span class='kw'>let</span> <span class='ident'>i</span>: <span class='ident'>usize</span> <span class='op'>=</span> <span class='number'>0</span>;
<span class='kw'>let</span> <span class='ident'>j</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>0</span>;

<span class='comment'>// funziona</span>
<span class='ident'>v</span>[<span class='ident'>i</span>];

<span class='comment'>// non funziona</span>
<span class='ident'>v</span>[<span class='ident'>j</span>];</pre>

<p>Indicizzare con un tipo diverso da <code>usize</code> dà un errore come questo:</p>

<pre><code class="language-text">error: the trait bound `collections::vec::Vec&lt;_&gt; : core::ops::Index&lt;i32&gt;`
is not satisfied [E0277]
v[j];
^~~~
note: the type `collections::vec::Vec&lt;_&gt;` cannot be indexed by `i32`
error: aborting due to previous error
</code></pre>

<p>C&#39;è molta punteggiatura in quel messaggio, ma il suo nucleo significa:
non si può indicizzare con un <code>i32</code>.</p>

<h2 id='accesso-fuori-dai-limiti' class='section-header'><a href='#accesso-fuori-dai-limiti'>Accesso fuori dai limiti</a></h2>
<p>Se si prova ad accedere un indice che non esiste:</p>

<span class='rusttest'>fn main() {
    let v = vec![1, 2, 3];
println!(&quot;L&#39;elemento 7 è {}&quot;, v[7]);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;L&#39;elemento 7 è {}&quot;</span>, <span class='ident'>v</span>[<span class='number'>7</span>]);</pre>

<p>allora il thread attuale andrà in [panico] con un messaggio come questo:</p>

<pre><code class="language-text">thread &#39;main&#39; panicked at &#39;index out of bounds: the len is 3 but the index is 7&#39;
</code></pre>

<p>Se si vuole gestire gli errori di accesso fuori dai limiti senza andare
in panico, si possono usare metodi come <a href="../std/vec/struct.Vec.html#method.get"><code>get</code></a> o <a href="../std/vec/struct.Vec.html#method.get_mut"><code>get_mut</code></a>,
che restituiscono <code>None</code> quando gli viene dato un indice invalido:</p>

<span class='rusttest'>fn main() {
    let v = vec![1, 2, 3];
match v.get(7) {
    Some(x) =&gt; println!(&quot;Item 7 is {}&quot;, x),
    None =&gt; println!(&quot;Spiacente, questo vettore è troppo corto.&quot;)
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];
<span class='kw'>match</span> <span class='ident'>v</span>.<span class='ident'>get</span>(<span class='number'>7</span>) {
    <span class='prelude-val'>Some</span>(<span class='ident'>x</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Item 7 is {}&quot;</span>, <span class='ident'>x</span>),
    <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Spiacente, questo vettore è troppo corto.&quot;</span>)
}</pre>

<h2 id='iterare' class='section-header'><a href='#iterare'>Iterare</a></h2>
<p>Una volta che si ha un vettore, si può iterare sui suoi elementi usando <code>for</code>.
Ce ne sono tre versioni:</p>

<span class='rusttest'>fn main() {
    let mut v = vec![1, 2, 3, 4, 5];

for i in &amp;v {
    println!(&quot;Un riferimento a {}&quot;, i);
}

for i in &amp;mut v {
    println!(&quot;Un riferimento mutabile a {}&quot;, i);
}

for i in v {
    println!(&quot;Prendi il possesso del vettore e del suo elemento {}&quot;, i);
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>];

<span class='kw'>for</span> <span class='ident'>i</span> <span class='kw'>in</span> <span class='kw-2'>&amp;</span><span class='ident'>v</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Un riferimento a {}&quot;</span>, <span class='ident'>i</span>);
}

<span class='kw'>for</span> <span class='ident'>i</span> <span class='kw'>in</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>v</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Un riferimento mutabile a {}&quot;</span>, <span class='ident'>i</span>);
}

<span class='kw'>for</span> <span class='ident'>i</span> <span class='kw'>in</span> <span class='ident'>v</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Prendi il possesso del vettore e del suo elemento {}&quot;</span>, <span class='ident'>i</span>);
}</pre>

<p>Nota: Non si può usare ancora il vettore dopo averlo iterato prendendone
il possesso. Invece, si può iterare il vettore più volte se quando lo si itera
se ne prende un riferimento.
Per esempio, il seguente codice non compila.</p>

<span class='rusttest'>fn main() {
    let v = vec![1, 2, 3, 4, 5];

for i in v {
    println!(&quot;Prendi possesso del vettore e del suo elemento {}&quot;, i);
}

for i in v {
    println!(&quot;Prendi possesso del vettore e del suo elemento {}&quot;, i);
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>];

<span class='kw'>for</span> <span class='ident'>i</span> <span class='kw'>in</span> <span class='ident'>v</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Prendi possesso del vettore e del suo elemento {}&quot;</span>, <span class='ident'>i</span>);
}

<span class='kw'>for</span> <span class='ident'>i</span> <span class='kw'>in</span> <span class='ident'>v</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Prendi possesso del vettore e del suo elemento {}&quot;</span>, <span class='ident'>i</span>);
}</pre>

<p>Mentre il seguente funziona perfettamente:</p>

<span class='rusttest'>fn main() {
    let v = vec![1, 2, 3, 4, 5];

for i in &amp;v {
    println!(&quot;Questo è un riferimento a {}&quot;, i);
}

for i in &amp;v {
    println!(&quot;Questo è un riferimento a {}&quot;, i);
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>];

<span class='kw'>for</span> <span class='ident'>i</span> <span class='kw'>in</span> <span class='kw-2'>&amp;</span><span class='ident'>v</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Questo è un riferimento a {}&quot;</span>, <span class='ident'>i</span>);
}

<span class='kw'>for</span> <span class='ident'>i</span> <span class='kw'>in</span> <span class='kw-2'>&amp;</span><span class='ident'>v</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Questo è un riferimento a {}&quot;</span>, <span class='ident'>i</span>);
}</pre>

<p>I vettori hanno molti altri metodi utili, di cui si può leggere nella
<a href="../std/vec/index.html">documentazione della loro API</a>.</p>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>