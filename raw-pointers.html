<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Puntatori grezzi</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduzione</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Come Iniziare</a>
</li>
<li><a  href='guessing-game.html'><b>3.</b> Tutorial: Gioco-indovina</a>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> Sintassi e semantica</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>4.1.</b> Legami di variabili</a>
</li>
<li><a  href='functions.html'><b>4.2.</b> Funzioni</a>
</li>
<li><a  href='primitive-types.html'><b>4.3.</b> Tipi primitivi</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> Commenti</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>4.6.</b> Cicli</a>
</li>
<li><a  href='vectors.html'><b>4.7.</b> Vettori</a>
</li>
<li><a  href='ownership.html'><b>4.8.</b> Possesso</a>
</li>
<li><a  href='references-and-borrowing.html'><b>4.9.</b> Riferimenti e prestito</a>
</li>
<li><a  href='lifetimes.html'><b>4.10.</b> Tempo di vita</a>
</li>
<li><a  href='mutability.html'><b>4.11.</b> Mutabilità</a>
</li>
<li><a  href='structs.html'><b>4.12.</b> Strutture</a>
</li>
<li><a  href='enums.html'><b>4.13.</b> Enumerazioni</a>
</li>
<li><a  href='match.html'><b>4.14.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>4.15.</b> Pattern</a>
</li>
<li><a  href='method-syntax.html'><b>4.16.</b> Sintassi dei metodi</a>
</li>
<li><a  href='strings.html'><b>4.17.</b> Stringhe</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> Genericità</a>
</li>
<li><a  href='traits.html'><b>4.19.</b> Tratti</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> `if let`</a>
</li>
<li><a  href='trait-objects.html'><b>4.22.</b> Oggetti-tratti</a>
</li>
<li><a  href='closures.html'><b>4.23.</b> Chiusure</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> Sintassi universale di chiamata di funzione</a>
</li>
<li><a  href='crates-and-modules.html'><b>4.25.</b> Crate e moduli</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const` e `static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> Attributi</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> Alias tramite `type`</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> Forzatura di tipo</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> Tipi associati</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> Tipi non dimensionati</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> Operatori e sovraccaricamento</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Coercizione Deref</a>
</li>
<li><a  href='macros.html'><b>4.34.</b> Le macro</a>
</li>
<li><a class='active' href='raw-pointers.html'><b>4.35.</b> Puntatori grezzi</a>
</li>
<li><a  href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Rust efficace</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> Lo stack e lo heap</a>
</li>
<li><a  href='testing.html'><b>5.2.</b> Collaudo</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> Compilazione condizionale</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> Documentazione</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> Iteratori</a>
</li>
<li><a  href='concurrency.html'><b>5.6.</b> Concorrenza</a>
</li>
<li><a  href='error-handling.html'><b>5.7.</b> Gestione degli errori</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> Scegliere le garanzie</a>
</li>
<li><a  href='ffi.html'><b>5.9.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> Prestito e AsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> Canali di rilascio</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> Usare Rust senza la libreria standard</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Rust notturno</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Plugin del compilatore</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Assembly in-line</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> Omettere la libreria stdandard</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinseci</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Elementi "lang"</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> Link avanzato</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Collaudi prestazionali</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Sintassi di box e relativi pattern</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Pattern di slice</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Costanti associate</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> Allocatori personalizzati</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> Glossario</a>
</li>
<li><a  href='syntax-index.html'><b>8.</b> Indice analitico della sintassi</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Puntatori grezzi</h1>
    <p>Rust ha vari diversi tipi di smart pointer nella sua libreria standard, ma
ci sono due tipi che sono molto speciali. Molto della sicurezza di Rust deriva
dalle verifiche in fase di compilazione, ma i puntatori grezzi non hanno
tali garanzie, e quindi sono <a href="unsafe.html">insicuri</a> da usare.</p>

<p><code>*const T</code> e <code>*mut T</code> sono chiamati ‘puntatori grezzi’ [&quot;raw pointer&quot;] in Rust.
Talvolta, quando si scrivono certi tipi di librerie, c&#39;è bisogno di aggirare
le garanzie di sicurezza di Rust, per varie ragioni. In tali casi, si possono
usare i puntatori grezzi nell&#39;implementazione della propria libreria, pur
esponendo un&#39;interfaccia sicura ai propri utenti. Per esempio, i puntatori <code>*</code>
sono consentiti eseguire degli alias, consentendogli di essere usati
per scrivere dei tipi di possesso condiviso, e perfino dei tipi di memoria
condivisa thread-safe (i tipi <code>Rc&lt;T&gt;</code> e <code>Arc&lt;T&gt;</code> sono entrambi implementati
interamente in Rust).</p>

<p>Ecco alcune cose da ricordare sui puntatori grezzi, che sono diverse
dagli altri tipi di puntatori. Tali puntatori: </p>

<ul>
<li>non è garantito che puntino a memoria valida, e non è nemmeno garanito
che non siano NULL (diversamente sia da <code>Box</code> che da <code>&amp;</code>);</li>
<li>non fanno nessuna pulizia automatica, diversamente da <code>Box</code>, e perciò
richiedono una gestione manuale delle risorse;</li>
<li>sono dei POD (&quot;plain-old-data&quot;), cioè non spostano il possesso, ancora
diversamente da <code>Box</code>, e perciò il compilatore Rust non può proteggere
da difetti come l&#39;uso dopo da deallocazione;</li>
<li>non hanno nessuna forma di tempo di vita, diversamente da <code>&amp;</code>, e quindi
il compilatore non può rilevare i puntatori penzolanti;</li>
<li>non danno garanzie sull&#39;aliasing né sulla mutabilità, a parte il fatto che
la mutazione non è consentita direttamente tramite un <code>*const T</code>.</li>
</ul>

<h1 id='fondamenti' class='section-header'><a href='#fondamenti'>Fondamenti</a></h1>
<p>Creare un puntatore grezzo è perfettamente sicuro:</p>

<span class='rusttest'>fn main() {
    let x = 5;
let grezzo = &amp;x as *const i32;

let mut y = 10;
let grezzo_mut = &amp;mut y as *mut i32;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='kw'>let</span> <span class='ident'>grezzo</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>x</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>i32</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>10</span>;
<span class='kw'>let</span> <span class='ident'>grezzo_mut</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>y</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>i32</span>;</pre>

<p>Però, dereferenziarne uno non lo è. Questo non funziona:</p>

<span class='rusttest'>fn main() {
    let x = 5;
let grezzo = &amp;x as *const i32;

println!(&quot;grezzo punta a {}&quot;, *grezzo);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='kw'>let</span> <span class='ident'>grezzo</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>x</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>i32</span>;

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;grezzo punta a {}&quot;</span>, <span class='op'>*</span><span class='ident'>grezzo</span>);</pre>

<p>Dà quessto errore:</p>

<pre><code class="language-text">error: dereference of raw pointer requires unsafe function or block [E0133]
println!(&quot;grezzo punta a {}&quot;, *grezzo);
                              ^~~~
</code></pre>

<p>Quando si dereferenza un puntatore grezzo, si sta assumendo la responsabilità
che non stia puntando da qualche luogo dove non dovrebbe. Pertanto, serve
<code>unsafe</code>:</p>

<span class='rusttest'>fn main() {
    let x = 5;
let grezzo = &amp;x as *const i32;

let punta_a = unsafe { *grezzo };

println!(&quot;grezzo punta a {}&quot;, *grezzo);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='kw'>let</span> <span class='ident'>grezzo</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>x</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>i32</span>;

<span class='kw'>let</span> <span class='ident'>punta_a</span> <span class='op'>=</span> <span class='kw'>unsafe</span> { <span class='op'>*</span><span class='ident'>grezzo</span> };

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;grezzo punta a {}&quot;</span>, <span class='op'>*</span><span class='ident'>grezzo</span>);</pre>

<p>Per vedere altre operazioni sui puntatori grezzi, si veda la documentazione
della loro <a href="../std/primitive.pointer.html">API</a>.</p>

<h1 id='ffi' class='section-header'><a href='#ffi'>FFI</a></h1>
<p>I puntatori grezzi sono utili per l&#39;FFI: i <code>*const T</code> e i <code>*mut T</code> di Rust
sono simili, rispettivamente, ai <code>const T*</code> e ai <code>T*</code> del C. Per maggiori
informazioni su questo utilizzo, si consulti il capitolo <a href="ffi.html">FFI</a>.</p>

<h1 id='riferimenti-e-puntatori-grezzi' class='section-header'><a href='#riferimenti-e-puntatori-grezzi'>Riferimenti e puntatori grezzi</a></h1>
<p>In fase di esecuzione, un puntatore grezzo <code>*</code> e un riferimento che puntano
allo stesso dato hanno un&#39;identica rappresentazione. Di fatto, un riferimento
<code>&amp;T</code> sarà implicitamente forzato a un  puntatore grezzo <code>*const T</code> nel codice
sicuro e similmente avverrà per le varianti <code>mut</code> (entrambe le forzature
possono essere eseguite esplicitamente, rispettivamente, condivisa
<code>value as *const T</code> e con <code>value as *mut T</code>).</p>

<p>Invece, andare nella direzione opposta, da un <code>*const</code> a un riferimento <code>&amp;</code>,
non è sicuro. Un <code>&amp;T</code> è sempre valido, e così, come minimo, il puntatore grezzo
<code>*const T</code>deve puntare a un&#39;istanza valida del tipo <code>T</code>. Inoltre, il puntatore
risultante deve soddisfare le leggi di aliasing e mutabilità laws
dei riferimenti. Il compilatore assume che queste proprietà siano vere
per ogni riferimento, indipendentemente da come sono stati creati,
e così ogni conversione da puntatori grezzi sta asserendo che valgano.
Il programmatore <em>deve</em> garantirlo.</p>

<p>Il metodo consigliato per questa conversione è:</p>

<span class='rusttest'>fn main() {
    // cast esplicito
let i: u32 = 1;
let p_imm: *const u32 = &amp;i as *const u32;

// forzatura implicita
let mut m: u32 = 2;
let p_mut: *mut u32 = &amp;mut m;

unsafe {
    let ref_imm: &amp;u32 = &amp;*p_imm;
    let ref_mut: &amp;mut u32 = &amp;mut *p_mut;
}
}</span><pre class='rust rust-example-rendered'>
<span class='comment'>// cast esplicito</span>
<span class='kw'>let</span> <span class='ident'>i</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='number'>1</span>;
<span class='kw'>let</span> <span class='ident'>p_imm</span>: <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>u32</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>i</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>u32</span>;

<span class='comment'>// forzatura implicita</span>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>m</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='number'>2</span>;
<span class='kw'>let</span> <span class='ident'>p_mut</span>: <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>u32</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>m</span>;

<span class='kw'>unsafe</span> {
    <span class='kw'>let</span> <span class='ident'>ref_imm</span>: <span class='kw-2'>&amp;</span><span class='ident'>u32</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='op'>*</span><span class='ident'>p_imm</span>;
    <span class='kw'>let</span> <span class='ident'>ref_mut</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>u32</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='op'>*</span><span class='ident'>p_mut</span>;
}</pre>

<p>Lo stile di dereferenziazione <code>&amp;*x</code> è preferibile rispetto a usare <code>transmute</code>.
L&#39;ultimo stile è molto più potente del necessario, e l&#39;operazione più ristretta
è più difficile da usare scorrettamente; per esempio, richiede che <code>x</code>
sia un puntatore, diversamente da <code>transmute</code>.</p>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>